#include "keon_ble.h"
#include "config.h"
#include <BLEUtils.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GLOBAL STATE VARIABLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BLEClient* keonClient = nullptr;
BLERemoteCharacteristic* keonTxCharacteristic = nullptr;
BLEAddress keonAddress(KEON_MAC_ADDRESS);

bool keonConnected = false;
uint8_t keonCurrentPosition = 50;
uint8_t keonCurrentSpeed = 0;

static uint32_t lastKeonCommand = 0;
static bool keonInitialized = false;
static String lastConnectedMAC = "";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BLE CALLBACK HANDLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class KeonClientCallback : public BLEClientCallbacks {
  void onConnect(BLEClient* pclient) {
    keonConnected = true;
    Serial.println("[KEON] BLE Connected");
  }
  void onDisconnect(BLEClient* pclient) {
    keonConnected = false;
    Serial.println("[KEON] BLE Disconnected");
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMMAND SENDING WITH RATE LIMITER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

static bool keonSendCommand(uint8_t* data, size_t length) {
  if (!keonConnected || keonTxCharacteristic == nullptr) {
    return false;
  }

  uint32_t now = millis();
  if ((now - lastKeonCommand) < KEON_COMMAND_DELAY_MS) {
    return false;
  }

  try {
    keonTxCharacteristic->writeValue(data, length, true);
    lastKeonCommand = now;
    return true;
  } catch (...) {
    try {
      keonTxCharacteristic->writeValue(data, length, false);
      lastKeonCommand = now;
      return true;
    } catch (...) {
      return false;
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOVEMENT CONTROL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool keonMove(uint8_t position, uint8_t speed) {
  if (position > 99) position = 99;
  if (speed > 99) speed = 99;

  keonCurrentPosition = position;
  keonCurrentSpeed = speed;

  uint8_t cmd[5] = {0x04, 0x00, position, 0x00, speed};
  return keonSendCommand(cmd, 5);
}

bool keonStopAtPosition(uint8_t position) {
  if (position > 99) position = 99;
  uint8_t cmd[5] = {0x04, 0x00, position, 0x00, 0x00};
  return keonSendCommand(cmd, 5);
}

bool keonStop() {
  return keonStopAtPosition(keonCurrentPosition);
}

bool keonMoveSlow(uint8_t position) {
  return keonMove(position, 33);
}

bool keonMoveMedium(uint8_t position) {
  return keonMove(position, 66);
}

bool keonMoveFast(uint8_t position) {
  return keonMove(position, 99);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONNECTION MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void keonInit() {
  if (keonInitialized) return;
  BLEDevice::init("HoofdESP_KeonController");
  keonInitialized = true;
  Serial.println("[KEON] BLE initialized");
}

bool keonConnect() {
  if (!keonInitialized) {
    keonInit();
  }

  Serial.println("[KEON] Attempting connection...");
  
  keonClient = BLEDevice::createClient();
  keonClient->setClientCallbacks(new KeonClientCallback());

  if (!keonClient->connect(keonAddress)) {
    Serial.println("[KEON] Connection failed!");
    return false;
  }

  delay(500);

  BLERemoteService* pRemoteService = keonClient->getService(KEON_SERVICE_UUID);
  if (pRemoteService == nullptr) {
    Serial.println("[KEON] Service not found!");
    keonClient->disconnect();
    return false;
  }

  keonTxCharacteristic = pRemoteService->getCharacteristic(KEON_TX_CHAR_UUID);

  if (keonTxCharacteristic == nullptr) {
    Serial.println("[KEON] TX Characteristic not found, searching...");
    std::map<std::string, BLERemoteCharacteristic*>* characteristics = pRemoteService->getCharacteristics();
    if (characteristics != nullptr) {
      for (auto &entry : *characteristics) {
        BLERemoteCharacteristic* pChar = entry.second;
        if (pChar->canWrite() || pChar->canWriteNoResponse()) {
          keonTxCharacteristic = pChar;
          Serial.println("[KEON] Found writable characteristic!");
          break;
        }
      }
    }
  }

  if (keonTxCharacteristic == nullptr) {
    Serial.println("[KEON] No writable characteristic found!");
    keonClient->disconnect();
    return false;
  }

  keonConnected = true;
  lastConnectedMAC = String(KEON_MAC_ADDRESS);
  Serial.printf("[KEON] Connected successfully to %s\n", KEON_MAC_ADDRESS);
  return true;
}

void keonDisconnect() {
  if (keonConnected && keonClient != nullptr) {
    Serial.println("[KEON] Disconnecting...");
    keonStop();
    delay(200);
    keonClient->disconnect();
    keonConnected = false;
    keonTxCharacteristic = nullptr;
  }
}

bool keonIsConnected() {
  return keonConnected && keonClient != nullptr && keonTxCharacteristic != nullptr;
}

void keonCheckConnection() {
  if (keonConnected && keonClient != nullptr) {
    if (!keonClient->isConnected()) {
      Serial.println("[KEON] Connection lost!");
      keonConnected = false;
      keonTxCharacteristic = nullptr;
    }
  }
}

void keonReconnect() {
  Serial.println("[KEON] Manual reconnect...");
  if (keonConnected) {
    keonDisconnect();
  }
  keonConnect();
}

String keonGetLastMAC() {
  return lastConnectedMAC;
}

void keonSetMAC(const char* mac) {
  lastConnectedMAC = String(mac);
  Serial.printf("[KEON] MAC set to: %s (requires recompile)\n", mac);
}

void keonParkToBottom() {
  if (!keonConnected) return;
  Serial.println("[KEON] Parking to bottom");
  keonMove(0, 50);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš€ DUAL-CORE KEON CONTROL - RUNS ON CORE 0!
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Plak deze keonIndependentTick() functie in je keon_ble.cpp
// Vervang de oude versie

void keonIndependentTick() {
  if (!keonConnected) return;
  
  extern bool paused;
  
  static bool keonDirection = false;
  static uint32_t lastCommand = 0;
  static uint32_t strokeCount = 0;
  static bool wasRunning = false;
  
  uint32_t now = millis();
  extern uint8_t g_speedStep;
  
  // PAUSE HANDLING
  if (paused) {
    if (wasRunning) {
      Serial.println("[KEON CORE0] Paused - parking");
      keonMove(0, 50);
      wasRunning = false;
      keonDirection = false;
    }
    return;
  }
  
  // RESUME
  if (!wasRunning) {
    Serial.println("[KEON CORE0] Resumed");
    wasRunning = true;
    lastCommand = now - 2500;
  }
  
  /*
  // âœ… VASTE INTERVAL - ALLE LEVELS ZELFDE TIMING
  uint32_t interval = 2500;  // 2.5 seconden tussen toggles
  
  if ((now - lastCommand) < interval) {
    return;
  }
  
  // âœ… VARIABELE SPEED - DIT GEEFT HET SNELHEIDSVERSCHIL!
  // Level 0: Speed 30 (motor gaat langzaam â†’ voelt traag)
  // Level 7: Speed 99 (motor gaat snel â†’ voelt snel)
  //uint8_t motorSpeed = 30 + ((g_speedStep * 69) / 7);
  //uint8_t motorSpeed = 70 + ((g_speedStep * 29) / 7);
  //uint8_t motorSpeed = 99;
  uint8_t motorSpeed = 40;
  */

/*  
// âœ… VARIABELE INTERVAL: Motor heeft tijd nodig bij lage speed!
static uint32_t levelIntervals[8] = {
  5000,  // Level 0: Lang interval voor trage motor
  4500,
  4000,
  3500,
  3000,
  2500,
  2000,
  1500   // Level 7: Kort interval, motor is snel
};

uint32_t interval = levelIntervals[g_speedStep];

if ((now - lastCommand) < interval) {
  return;
}

// âœ… VARIABELE SPEED: 40-99
uint8_t motorSpeed = 40 + ((g_speedStep * 59) / 7);
*/

// âœ… LANGE INTERVAL (genoeg tijd voor langzame motor!)
uint32_t interval = 5000;  // 5 seconden voor alle levels

if ((now - lastCommand) < interval) {
  return;
}

// âœ… VARIABELE SPEED: 50-99
// Level 0: Speed 50 (motor langzaam)
// Level 7: Speed 99 (motor snel)
uint8_t motorSpeed = 50 + ((g_speedStep * 49) / 7);

uint8_t targetPos = keonDirection ? 99 : 0;
keonMove(targetPos, motorSpeed);

  // TOGGLE & SEND
  keonDirection = !keonDirection;
  uint8_t targetPos = keonDirection ? 99 : 0;
  
  bool sent = keonMove(targetPos, motorSpeed);  // â† VARIABELE SPEED!
  
  if (sent) {
    lastCommand = now;
    strokeCount++;
    
    Serial.printf("[KEON CORE0 #%u] %sâ†’%u Speed:%u L:%u\n",
                  strokeCount,
                  keonDirection ? "UP" : "DOWN",
                  targetPos,
                  motorSpeed,
                  g_speedStep);
    
    if (strokeCount % 10 == 0) {
      Serial.printf("[KEON CORE0] ===== 10 strokes L:%u Speed:%u =====\n", 
                    g_speedStep, motorSpeed);
    }
  } else {
    keonDirection = !keonDirection;
  }
}


/*
void keonIndependentTick() {
  if (!keonConnected) return;
  
  extern bool paused;
  
  static bool keonDirection = false;
  static uint32_t lastCommand = 0;
  static uint32_t strokeCount = 0;
  static bool wasRunning = false;
  
  uint32_t now = millis();
  extern uint8_t g_speedStep;
  
  // PAUSE HANDLING
  if (paused) {
    if (wasRunning) {
      Serial.println("[KEON CORE0] Paused - parking");
      keonMove(0, 50);
      wasRunning = false;
      keonDirection = false;
    }
    return;
  }
  
  // RESUME
  if (!wasRunning) {
    Serial.println("[KEON CORE0] Resumed");
    wasRunning = true;
    lastCommand = now - 2000;
  }
  
  static uint32_t levelIntervals[8] = {
    4000,  // Level 0: 15 strokes/min - ZEER LANGZAAM
    3500,  // Level 1: 17 strokes/min
    3000,  // Level 2: 20 strokes/min
    2500,  // Level 3: 24 strokes/min
    2200,  // Level 4: 27 strokes/min
    1900,  // Level 5: 32 strokes/min
    1600,  // Level 6: 38 strokes/min
    1400   // Level 7: 43 strokes/min - SNEL (maar Keon heeft tijd!)
  };*/

  /*
  // âœ… GEFIXTE INTERVALS - DUIDELIJK VERSCHIL TUSSEN LEVELS!
  static uint32_t levelIntervals[8] = {
    3000,  // Level 0: 20 strokes/min - ZEER LANGZAAM
    2600,  // Level 1: 23 strokes/min
    2200,  // Level 2: 27 strokes/min
    1800,  // Level 3: 33 strokes/min
    1400,  // Level 4: 43 strokes/min
    1100,  // Level 5: 55 strokes/min
    900,   // Level 6: 67 strokes/min
    700    // Level 7: 86 strokes/min - SNEL
  };*/
  /*
  uint32_t interval = levelIntervals[g_speedStep];
  
  if ((now - lastCommand) < interval) {
    return;
  }
  
  // âœ… TOGGLE & SEND - VOLLE RANGE (0-99) VOOR ALLE LEVELS
  keonDirection = !keonDirection;
  uint8_t targetPos = keonDirection ? 99 : 0;
  
  bool sent = keonMove(targetPos, 99);  // Speed altijd 99!
  
  if (sent) {
    lastCommand = now;
    strokeCount++;
    
    Serial.printf("[KEON CORE0 #%u] %sâ†’%u L:%u Int:%ums\n",
                  strokeCount,
                  keonDirection ? "UP" : "DOWN",
                  targetPos,
                  g_speedStep,
                  interval);
    
    if (strokeCount % 10 == 0) {
      Serial.printf("[KEON CORE0] ===== 10 strokes L:%u (%.1f/min) =====\n", 
                    g_speedStep,
                    60000.0f / (interval * 2.0f));
    }
  } else {
    keonDirection = !keonDirection;
  }
}*/

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FREERTOS TASK - DEDICATED KEON CONTROL ON CORE 0
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void keonTask(void* parameter) {
  Serial.println("[KEON TASK] Started on Core 0");
  
  while(true) {
    keonCheckConnection();
    keonIndependentTick();
    vTaskDelay(1 / portTICK_PERIOD_MS);
  }
}

static TaskHandle_t keonTaskHandle = NULL;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// START/STOP KEON TASK ON CORE 0
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void keonStartTask() {
  if (keonTaskHandle != NULL) {
    Serial.println("[KEON TASK] Already running!");
    return;
  }
  
  xTaskCreatePinnedToCore(
    keonTask,
    "KeonTask",
    4096,
    NULL,
    1,
    &keonTaskHandle,
    0  // Core 0!
  );
  
  Serial.println("[KEON TASK] Created on Core 0!");
}

void keonStopTask() {
  if (keonTaskHandle != NULL) {
    vTaskDelete(keonTaskHandle);
    keonTaskHandle = NULL;
    Serial.println("[KEON TASK] Stopped");
  }
}
