/*
  Body ESP SC01 Plus - Minimale Werkende Versie
  Focus: Display + Grafieken + Touch + Sensors
  
  Uitgeschakeld:
  - Menu systeem (crasht)
  - SD card recording (faalt init)
  - RTC (hangt systeem)
*/

// Touch calibratie
#define TOUCH_ROTATION  0
#define USE_MANUAL_MAPPING  1
#define MANUAL_SWAP_XY   1
#define MANUAL_FLIP_X    0
#define MANUAL_FLIP_Y    1

#include <Arduino.h>
#include <Wire.h>
#include <Arduino_GFX_Library.h>
#include <FT6X36.h>
#include <Adafruit_ADS1X15.h>
#include <SD.h>
#include <esp_now.h>
#include <WiFi.h>
#include "config.h"
#include "body_gfx4.h"
#include "body_fonts.h"
#include "ads1115_sensors.h"
#include "sensor_settings.h"

// Screen
const int SCR_W = 480;
const int SCR_H = 320;
#define GFX_BL 45

extern Arduino_GFX *body_gfx;
#define gfx body_gfx

// Touch
#define TOUCH_SDA 6
#define TOUCH_SCL 5
#define TOUCH_INT -1
FT6X36 *ts = nullptr;

// Sensors
#define SENSOR_SDA 10
#define SENSOR_SCL 11
extern Adafruit_ADS1115 ads;
bool adsAvailable = false;

// SD Card
#define SD_CS_PIN 41
bool sdCardAvailable = false;
File recordingFile;
uint32_t recordingStartTime = 0;
uint32_t samplesRecorded = 0;
int nextFileNumber = 1;

// ESP-NOW
static uint8_t hoofdESP_MAC[] = {0xE4, 0x65, 0xB8, 0x7A, 0x85, 0xE4};
static uint8_t bodyESP_MAC[] = {0xE8, 0x06, 0x90, 0xDD, 0x7E, 0x18};
static bool espNowInitialized = false;
static uint32_t lastCommTime = 0;
static float trustSpeed = 0.0f, sleeveSpeed = 0.0f;
static bool vibeOn = false;
static bool zuigActive = false;
static float vacuumMbar = 0.0f;
static bool pauseActive = false;

// UI
bool isRecording = false;
bool isPlaying = false;
bool aiOverruleActive = false;
volatile bool touchDetected = false;
volatile uint16_t touchX = 0, touchY = 0;
static uint32_t lastButtonTouch = 0;
static uint32_t lastSensorPush = 0;

typedef struct __attribute__((packed)) {
  float trust, sleeve, suction, pause;
  bool vibeOn, zuigActive, pauseActive;
  float vacuumMbar;
  char command[32];
} esp_now_receive_message_t;

typedef struct __attribute__((packed)) {
  float newTrust, newSleeve;
  bool overruleActive;
  uint8_t stressLevel;
  char command[32];
} esp_now_send_message_t;

static void onESPNowReceive(const esp_now_recv_info *info, const uint8_t *data, int len) {
  if (len == sizeof(esp_now_receive_message_t)) {
    esp_now_receive_message_t msg;
    memcpy(&msg, data, sizeof(msg));
    trustSpeed = msg.trust;
    sleeveSpeed = msg.sleeve;
    vibeOn = msg.vibeOn;
    zuigActive = msg.zuigActive;
    vacuumMbar = msg.vacuumMbar;
    pauseActive = msg.pauseActive;
    lastCommTime = millis();
  }
}

static bool initESPNow() {
  WiFi.mode(WIFI_STA);
  WiFi.setChannel(4);
  if (esp_now_init() != ESP_OK) return false;
  esp_now_register_recv_cb(onESPNowReceive);
  
  esp_now_peer_info_t peerInfo;
  memset(&peerInfo, 0, sizeof(peerInfo));
  memcpy(peerInfo.peer_addr, hoofdESP_MAC, 6);
  peerInfo.channel = 4;
  peerInfo.encrypt = false;
  
  if (esp_now_add_peer(&peerInfo) != ESP_OK) return false;
  return true;
}

static bool sendESPNowMessage(float trust, float sleeve, bool overrule, const char* cmd) {
  if (!espNowInitialized) return false;
  esp_now_send_message_t msg;
  memset(&msg, 0, sizeof(msg));
  msg.newTrust = trust;
  msg.newSleeve = sleeve;
  msg.overruleActive = overrule;
  strncpy(msg.command, cmd, sizeof(msg.command) - 1);
  return esp_now_send(hoofdESP_MAC, (uint8_t*)&msg, sizeof(msg)) == ESP_OK;
}

void touchCallback(TPoint point, TEvent e) {
  static bool wasTouched = false;
  
  if (e == TEvent::Tap || e == TEvent::TouchStart) {
    wasTouched = true;
    return;
  }
  
  if (e == TEvent::TouchEnd) {
    if (!wasTouched) return;
    wasTouched = false;
  } else {
    return;
  }
  
  int16_t x = point.x, y = point.y;
  
  #if USE_MANUAL_MAPPING
    #if MANUAL_SWAP_XY
      int16_t temp = x; x = y; y = temp;
    #endif
    #if MANUAL_FLIP_X
      x = 480 - 1 - x;
    #endif
    #if MANUAL_FLIP_Y
      y = 320 - 1 - y;
    #endif
  #endif
  
  if (x < 0) x = 0; if (x >= 480) x = 479;
  if (y < 0) y = 0; if (y >= 320) y = 319;
  
  touchX = x; touchY = y; touchDetected = true;
  
  if (millis() - lastButtonTouch < 300) return;
  
  if (y >= 280 && y < 315) {
    lastButtonTouch = millis();
    
    if (x >= 5 && x < 117) {
      isRecording = !isRecording;
      if (isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
      body_gfx4_drawButtons(isRecording, isPlaying, false, aiOverruleActive);
      Serial.printf("[BUTTON] REC %s\n", isRecording ? "ON" : "OFF");
    }
    else if (x >= 122 && x < 234) {
      isPlaying = !isPlaying;
      body_gfx4_drawButtons(isRecording, isPlaying, false, aiOverruleActive);
      Serial.printf("[BUTTON] PLAY %s\n", isPlaying ? "ON" : "OFF");
    }
    else if (x >= 356 && x < 475) {
      aiOverruleActive = !aiOverruleActive;
      body_gfx4_drawButtons(isRecording, isPlaying, false, aiOverruleActive);
      Serial.printf("[BUTTON] AI %s\n", aiOverruleActive ? "ON" : "OFF");
    }
  }
}

void startRecording() {
  if (!sdCardAvailable) {
    Serial.println("[REC] No SD card!");
    isRecording = false;
    return;
  }
  
  String filename = "/data" + String(nextFileNumber) + ".csv";
  recordingFile = SD.open(filename, FILE_WRITE);
  
  if (recordingFile) {
    recordingFile.println("Time,Heart,Temp,Skin,Breath,Trust,Vibe,Suction");
    recordingStartTime = millis();
    samplesRecorded = 0;
    Serial.printf("[REC] Started: %s\n", filename.c_str());
  } else {
    isRecording = false;
    Serial.println("[REC] File open failed!");
  }
}

void stopRecording() {
  if (recordingFile) {
    recordingFile.close();
    Serial.printf("[REC] Stopped. Samples: %u\n", samplesRecorded);
    nextFileNumber++;
  }
}

void recordSample(float heart, float temp, float skin, float breath) {
  if (!isRecording || !recordingFile) return;
  
  uint32_t timeMs = millis() - recordingStartTime;
  recordingFile.printf("%u,%.1f,%.1f,%.1f,%.1f,%.1f,%d,%.1f\n",
                      timeMs, heart, temp, skin, breath, 
                      trustSpeed, vibeOn ? 1 : 0, vacuumMbar);
  samplesRecorded++;
  
  if (samplesRecorded % 100 == 0) {
    recordingFile.flush();
  }
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n=== Body ESP SC01 Plus - Minimal ===");
  
  // Display
  gfx->begin();
  gfx->setRotation(1);
  pinMode(GFX_BL, OUTPUT);
  digitalWrite(GFX_BL, HIGH);
  Serial.println("[DISPLAY] 480x320 OK");
  
  // Touch
  Wire.begin(TOUCH_SDA, TOUCH_SCL);
  Wire.setClock(400000);
  ts = new FT6X36(&Wire, TOUCH_INT);
  if (ts->begin()) {
    ts->registerTouchHandler(touchCallback);
    Serial.println("[TOUCH] FT6336U OK");
  } else {
    Serial.println("[TOUCH] FAILED!");
    while(1) delay(1000);
  }
  
  // Sensors
  Serial.println("[I2C] Starting Wire1...");
  Wire1.begin(SENSOR_SDA, SENSOR_SCL);
  Wire1.setClock(400000);
  
  if (ads1115_begin()) {
    adsAvailable = true;
    Serial.println("[SENSOR] ADS1115 OK");
    loadSensorConfig();
  } else {
    Serial.println("[SENSOR] ADS1115 FAILED - using dummy data");
  }
  
  // SD Card
  Serial.println("[SD] Initializing...");
  delay(500);
  if (SD.begin(SD_CS_PIN)) {
    sdCardAvailable = true;
    Serial.println("[SD] Card OK!");
    // Find next file number
    while (SD.exists("/data" + String(nextFileNumber) + ".csv")) {
      nextFileNumber++;
    }
    Serial.printf("[SD] Next file: data%d.csv\n", nextFileNumber);
  } else {
    Serial.println("[SD] Failed - no recording");
  }
  
  // ESP-NOW
  Serial.println("[ESP-NOW] Initializing...");
  espNowInitialized = initESPNow();
  if (espNowInitialized) {
    Serial.println("[ESP-NOW] OK");
    sendESPNowMessage(1.0f, 1.0f, false, "HEARTBEAT");
  }
  
  // Graphics
  Serial.println("[BODY_GFX4] Initializing...");
  body_gfx4_begin();
  body_gfx4_setLabel(G4_HART, "Hart");
  body_gfx4_setLabel(G4_HUID, "Huid");
  body_gfx4_setLabel(G4_TEMP, "Temp");
  body_gfx4_setLabel(G4_ADEMHALING, "Adem");
  body_gfx4_setLabel(G4_HOOFDESP, "Trust");
  body_gfx4_setLabel(G4_ZUIGEN, "Zuigen");
  body_gfx4_setLabel(G4_TRIL, "Vibe");
  Serial.println("[BODY_GFX4] Graphics ready!");
  
  Serial.println("[SYSTEM] Ready!\n");
}

void loop() {
  static bool first = true;
  if (first) {
    Serial.println("[LOOP] Started!");
    first = false;
  }
  
  // Touch polling
  if (ts) {
    ts->processTouch();
    ts->loop();
  }
  
  if (touchDetected) touchDetected = false;
  
  // Sensor data push (elke 100ms)
  if (millis() - lastSensorPush > SENSOR_INTERVAL_MS) {
    if (adsAvailable) {
      ads1115_readAll();
      ADS1115_SensorData data = ads1115_getData();
      body_gfx4_pushSample(G4_HART, data.BPM);
      body_gfx4_pushSample(G4_HUID, data.gsrSmooth / GSR_SCHAAL_FACTOR);
      body_gfx4_pushSample(G4_TEMP, data.temperature);
      body_gfx4_pushSample(G4_ADEMHALING, data.breathValue);
    } else {
      // Dummy data
      float t = millis() / 1000.0f;
      body_gfx4_pushSample(G4_HART, 70 + 20 * sin(t * 2));
      body_gfx4_pushSample(G4_HUID, 50 + 10 * sin(t * 0.5));
      body_gfx4_pushSample(G4_TEMP, 36.5 + 0.5 * sin(t * 0.3));
      body_gfx4_pushSample(G4_ADEMHALING, 16 + 4 * sin(t));
    }
    
    // ESP-NOW data
    static float thrustPhase = 0;
    if (!pauseActive && trustSpeed > 0.05f) {
      float thrustFreq = trustSpeed * TRUST_ANIM_SNELHEID;
      thrustPhase += thrustFreq * 0.1f;
      float thrustAnim = 50 + TRUST_ANIM_HOOGTE * sin(thrustPhase);
      body_gfx4_pushSample(G4_HOOFDESP, thrustAnim);
    } else {
      thrustPhase = 0;
      body_gfx4_pushSample(G4_HOOFDESP, 50);
    }
    
    body_gfx4_pushSample(G4_ZUIGEN, zuigActive ? 100 : 0);
    
    static float vibePhase = 0;
    if (vibeOn) {
      vibePhase += VIBE_ANIM_SNELHEID;
      if (vibePhase > 1.0f) vibePhase = 0;
      body_gfx4_pushSample(G4_TRIL, vibePhase * 100);
    } else {
      vibePhase = 0;
      body_gfx4_pushSample(G4_TRIL, 50);
    }
    
    lastSensorPush = millis();
  }
  
  // ESP-NOW heartbeat
  static uint32_t lastHeartbeat = 0;
  if (espNowInitialized && (millis() - lastHeartbeat > 5000)) {
    sendESPNowMessage(1.0f, 1.0f, false, "HEARTBEAT");
    lastHeartbeat = millis();
  }
  
  delay(10);
}
