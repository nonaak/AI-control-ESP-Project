// TEST 123

/*
  SC01 Plus Touch Test - FT6336U Calibratie
  
  Test touch controller met visual feedback
  - Rood scherm = niet geÃ¯nitialiseerd
  - Groen scherm = touch controller OK
  - Teken witte pixels waar je aanraakt
  - Serial output met touch coordinaten
*/

// ========== TOUCH CALIBRATIE INSTELLINGEN ==========
// METHODE 1: Gebruik rotatie (makkelijk)
// 0 = 0Â°   (portrait)
// 1 = 90Â°  (landscape, USB rechts)
// 2 = 180Â° (portrait, ondersteboven)
// 3 = 270Â° (landscape, USB links)
#define TOUCH_ROTATION  0   // 0, 1, 2, of 3

// METHODE 2: Handmatige controle (geavanceerd)
// Zet USE_MANUAL_MAPPING op 1 om rotatie te negeren en alles zelf in te stellen
#define USE_MANUAL_MAPPING  1   // 0 = gebruik TOUCH_ROTATION, 1 = gebruik onderstaande

// Als USE_MANUAL_MAPPING = 1, pas deze aan:
#define MANUAL_SWAP_XY   1   // 0 of 1 - wissel X en Y
#define MANUAL_FLIP_X    0   // 0 of 1 - spiegel X (horizontaal)
#define MANUAL_FLIP_Y    1   // 0 of 1 - spiegel Y (verticaal)
// ====================================================

#include <Arduino.h>
#include <Wire.h>
#include <Arduino_GFX_Library.h>
#include <FT6X36.h>             // Display Driver
#include "Fonts/FreeSansBold18pt7b.h" // Rood scherm text
#include "Fonts/FreeSans12pt7b.h"     // Rood scherm text
#include <Adafruit_ADS1X15.h>   // ADS1115 sensor library
#include <RTClib.h>             // RTC DS3231 library
#include <Adafruit_seesaw.h>    // I2C Rotory Encoder
#include <seesaw_neopixel.h>    // NeoPixel op encoder board
#include <SD_MMC.h>             // SD card voor CSV recording (SD_MMC mode)
#include <esp_now.h>            // ESP-NOW communicatie
#include <WiFi.h>               // WiFi voor ESP-NOW
#include "esp_task_wdt.h"       // ðŸ”¥ NIEUW: Watchdog timer
#include <Preferences.h>        // Voor touch settings opslag
#include "config.h"             // SC01 Plus configuratie (eenvoudig)
#include "body_config.h"        // Body ESP configuratie (geavanceerd)
#include "body_gfx4.h"          // Grafisch systeem
#include "body_fonts.h"         // Font configuratie
#include "ads1115_sensors.h"    // ADS1115 sensor processing
#include "body_menu.h"          // Menu systeem
#include "sensor_settings.h"    // Sensor kalibratie (EEPROM)
#include "multifunplayer_client.h"  // MultiFunPlayer WebSocket client

// ========= TOUCH TOGGLE STATES (GLOBAAL) =========
bool touchEnabled = true;         // Global touch enable/disable
bool touchMenuEnabled = true;     // Touch voor menu navigatie
bool touchParamsEnabled = true;   // Touch voor parameters
bool touchEmergencyEnabled = true; // Touch voor emergency pause

// ========= PREFERENCES OBJECT =========
Preferences prefs;

// ðŸ”¥ NIEUW: Extern reference naar rendering pause flag
extern volatile bool g4_pauseRendering;

// ===== Screen dimensions voor SC01 Plus =====
const int SCR_W = 480;
const int SCR_H = 320;

// ===== SC01 Plus Display Pins =====
// Display wordt nu gedefinieerd in body_display.cpp
#define GFX_BL 45  // Backlight pin

// Gebruik extern display van body_display.cpp
extern Arduino_GFX *body_gfx;
#define gfx body_gfx  // Alias voor test code

// ===== Touch Controller =====
#define TOUCH_SDA 6
#define TOUCH_SCL 5
#define TOUCH_INT -1  // Polling mode

FT6X36 *ts = nullptr;
//U8G2_FOR_ADAFRUIT_GFX u8g2_fonts;

// ===== ADS1115 Sensor (Wire1 - GPIO 10/11) =====
#define SENSOR_SDA 10
#define SENSOR_SCL 11
// Adafruit_ADS1115 ads;  // VERWIJDERD - gedefinieerd in ads1115_sensors.cpp
extern Adafruit_ADS1115 ads;  // Extern reference
bool adsAvailable = false;

// ===== RTC DS3231 (Wire1 - I2C address 0x68) =====
RTC_DS3231 rtc;
bool rtcAvailable = false;

// ===== I2C EEPROM (Wire1 - AT24C02 256 bytes) =====
// A0=A1=A2=GND â†’ adres 0x50
bool eepromAvailable = false;
#define EEPROM_ADDR 0x50

// ===== Rotary Encoder (Wire1 - I2C address 0x36) =====
Adafruit_seesaw encoder(&Wire1);
seesaw_NeoPixel encoderPixel = seesaw_NeoPixel(1, 6, NEO_GRB + NEO_KHZ800, &Wire1);
#define ENCODER_ADDR 0x36
bool encoderAvailable = false;
bool encoderPixelAvailable = false;  // NeoPixel apart checken
int32_t encoderPosition = 0;

// Encoder state voor hoofdscherm
bool encoderActiveMainScreen = false;
int mainScreenButtonIdx = 0;  // 0=REC, 1=PLAY, 2=MENU, 3=AI

// Recording menu state
bool recordingInButtonMode = false;  // false = bestanden, true = knoppen

// Extern variabelen uit body_menu.cpp
extern int selectedRecordingFile;
extern int csvCount;

// AI Settings menu state
bool aiSettingsEditMode = false;
int aiSettingsEditingParam = -1;
bool aiParamModified[6] = {false};
float aiParamBackup[6];

// Sensor Settings menu state (NIEUW!)
bool sensorSettingsEditMode = false;
int sensorSettingsEditingParam = -1;
bool sensorParamModified[6] = {false};
float sensorParamBackup[6];

// Time Settings menu state (NIEUW!)
bool timeSettingsEditMode = false;
int timeSettingsEditingParam = -1;
bool timeParamModified[5] = {false};
int timeParamBackup[5];  // Jaar, Maand, Dag, Uur, Minuut

// Forward declaration voor AI Settings struct uit body_menu.cpp
struct AISettingsData {
  float autonomyLevel;
  float hrLow;
  float hrHigh;
  float tempMax;
  float gsrMax;
  float responseRate;
  bool aiEnabled;
};
extern AISettingsData aiSettings;

// Forward declaration voor Sensor Settings struct uit body_menu.cpp
struct SensorSettingsEdit {
  float beatThreshold;
  float tempOffset;
  float tempSmoothing;
  float gsrBaseline;
  float gsrSensitivity;
  float gsrSmoothing;
};
extern SensorSettingsEdit sensorEdit;

// Forward declaration voor Time Settings variabelen uit body_menu.cpp
extern int editYear, editMonth, editDay, editHour, editMinute;

// ===== ESP-NOW Communicatie =====
// MAC adressen van het netwerk
static uint8_t hoofdESP_MAC[] = {0xE4, 0x65, 0xB8, 0x7A, 0x85, 0xE4};  // HoofdESP
static uint8_t bodyESP_MAC[] = {0xE8, 0x06, 0x90, 0xDD, 0x7E, 0x18};   // Body ESP SC01 Plus (deze unit)

// ESP-NOW data variabelen
static uint32_t lastCommTime = 0;
static float trustSpeed = 0.0f, sleeveSpeed = 0.0f, suctionLevel = 0.0f;
static bool vibeOn = false;  // Handmatige VIBE toggle van HoofdESP
static bool zuigActive = false;  // Status zuigen modus actief
static float vacuumMbar = 0.0f;  // Vacuum waarde in mbar (0-10 bereik)
static bool pauseActive = false;  // C knop pauze status
static bool lubeTrigger = false;  // Lube cyclus start trigger
static float cyclusTijd = 10.0f;  // Cyclus duur in seconden
static uint32_t lastLubeTriggerTime = 0;  // Tijd van laatste lube trigger
static float sleevePercentage = 0.0f;  // Echte sleeve positie percentage (0-100)
static uint8_t hoofdESPSpeedStep = 3;  // Laatst ontvangen speed step van HoofdESP
static bool espNowInitialized = false;

// ESP-NOW ontvangst bericht structuur (van HoofdESP)
typedef struct __attribute__((packed)) {
  float trust;            // Trust speed (0.0-2.0)
  float sleeve;           // Sleeve speed (0.0-2.0)  
  float suction;          // Suction level (0.0-100.0)
  float pause;            // Pause tijd (0.0-10.0)
  bool vibeOn;            // Handmatige VIBE toggle van HoofdESP Z-knop
  bool zuigActive;        // Status zuigen modus actief (true/false)
  float vacuumMbar;       // Vacuum waarde in mbar (0-10 mbar bereik)
  bool pauseActive;       // C knop pauze status (true=gepauzeerd)
  bool lubeTrigger;       // Lube cyclus start trigger (sync punt)
  float cyclusTijd;       // Verwachte cyclus duur in seconden
  float sleevePercentage; // Sleeve positie percentage (0.0-100.0)
  uint8_t currentSpeedStep; // Huidige versnelling (0-7)
  char command[32];       // "STATUS_UPDATE"
} esp_now_receive_message_t;

// ESP-NOW verzend bericht structuur (naar HoofdESP)
typedef struct __attribute__((packed)) {
  float newTrust;         // AI berekende trust override (0.0-1.0)
  float newSleeve;        // AI berekende sleeve override (0.0-1.0)
  bool overruleActive;    // AI overrule status
  uint8_t stressLevel;    // Stress level 1-7 voor playback/AI
  bool vibeOn;            // Vibe status voor playback
  bool zuigenOn;          // Zuigen status voor playback
  char command[32];       // "AI_OVERRIDE", "EMERGENCY_STOP", "HEARTBEAT", "PLAYBACK_STRESS"
} esp_now_send_message_t;

// ðŸ”¥ NIEUW: ESP-NOW Retry Queue (NA typedef!)
#define ESPNOW_QUEUE_SIZE 5
#define MAX_RETRIES 3
#define RETRY_DELAY_MS 100

struct ESPNowQueueItem {
  esp_now_send_message_t message;
  uint32_t timestamp;
  uint8_t retryCount;
  bool inUse;
};

static ESPNowQueueItem espNowQueue[ESPNOW_QUEUE_SIZE];
static int queueHead = 0;
static int queueTail = 0;
static int queueCount = 0;


// ===== Callback variabelen =====
volatile bool touchDetected = false;
volatile uint16_t touchX = 0;
volatile uint16_t touchY = 0;

// ===== Body GFX4 Touch Handler =====
// UI states voor knoppen
bool isRecording = false;
bool isPlaying = false;
bool menuActive = false;
bool aiOverruleActive = false;

// ===== Emergency Pause & Warm-up State =====
static bool emergencyPauseActive = false;
static bool emergencyPauseScreenDrawn = false;
static uint8_t levelBeforePause = 0;
static bool emergencyBlinkState = false;
static unsigned long lastEmergencyBlink = 0;
static uint32_t warmupStartTime = 0;
static bool warmupActive = false;

// ===== CSV Recording =====
File csvFile;
String csvFilename = "";
static uint32_t lastCSVWrite = 0;
const uint32_t CSV_WRITE_INTERVAL = 1000;  // Elke 1 seconde een regel schrijven
uint32_t recordingStartTime = 0;
uint32_t csvSampleCount = 0;

// ðŸ”¥ NIEUW: SD card write buffer (60 samples = 1 minuut bij 1 Hz)
#define SD_BUFFER_SIZE 60
static String csvBuffer[SD_BUFFER_SIZE];
static int bufferIndex = 0;
static unsigned long lastBufferFlush = 0;

// ========= ENCODER NEOPIXEL FUNCTIES =========
// Zet encoder LED kleur (dim = 10% brightness, helder = 100%)
void setEncoderLED(uint8_t r, uint8_t g, uint8_t b, bool bright = false) {
  if (!encoderPixelAvailable) return;
  if (!bright) {
    r = r / 10;
    g = g / 10;
    b = b / 10;
  }
  encoderPixel.setPixelColor(0, encoderPixel.Color(r, g, b));
  encoderPixel.show();
}

// Zet encoder LED uit
void setEncoderLEDOff() {
  if (!encoderPixelAvailable) return;
  encoderPixel.setPixelColor(0, 0);
  encoderPixel.show();
}

// Parameter edit gradient: paars (0) -> rood (+) / blauw (-)
void setEncoderLEDGradient(int delta) {
  if (!encoderPixelAvailable) return;
  delta = constrain(delta, -100, 100);
  
  int r, b;
  if (delta >= 0) {
    // 0 tot +100: paars naar rood
    r = 255;  // Altijd vol rood
    b = map(delta, 0, 100, 255, 0);  // 255 bij 0, 0 bij +100
  } else {
    // -100 tot 0: blauw naar paars
    r = map(delta, -100, 0, 0, 255);  // 0 bij -100, 255 bij 0
    b = 255;  // Altijd vol blauw
  }
  encoderPixel.setPixelColor(0, encoderPixel.Color(r, 0, b));
  encoderPixel.show();
}

// Haal RGB kleur voor menu knop
void getButtonColor(BodyMenuPage page, int idx, uint8_t &r, uint8_t &g, uint8_t &b) {
  r = 255; g = 255; b = 255;  // Default wit
  
  switch(page) {
    case BODY_PAGE_MAIN:
      switch(idx) {
        case 0: r=0; g=255; b=255; break;    // Cyaan
        case 1: r=0; g=255; b=0; break;      // Groen
        case 2: r=255; g=0; b=255; break;    // Magenta
        case 3: r=255; g=0; b=0; break;      // Rood
        case 4: r=255; g=255; b=0; break;    // Geel
        case 5: r=128; g=0; b=255; break;    // Paars
        case 6: r=0; g=0; b=255; break;      // Blauw
      }
      break;
    case BODY_PAGE_SENSOR_CAL:
      switch(idx) {
        case 0: r=0; g=255; b=0; break;
        case 1: r=0; g=255; b=255; break;
        case 2: r=255; g=165; b=0; break;
        case 3: r=255; g=0; b=0; break;
        case 4: r=0; g=0; b=255; break;
      }
      break;
    case BODY_PAGE_AI_SETTINGS:
      if (idx <= 5) { r=128; g=0; b=128; }
      else if (idx == 6) { r=128; g=0; b=255; }
      else if (idx == 7) { r=0; g=255; b=0; }
      else { r=0; g=0; b=255; }
      break;
    case BODY_PAGE_SENSOR_SETTINGS:
      if (idx <= 5) { r=255; g=255; b=0; }
      else if (idx == 6) { r=0; g=255; b=0; }
      else { r=0; g=0; b=255; }
      break;
    case BODY_PAGE_ML_TRAINING:
      switch(idx) {
        case 0: r=0; g=255; b=0; break;
        case 1: r=0; g=255; b=255; break;
        case 2: r=255; g=0; b=255; break;
        case 3: r=255; g=165; b=0; break;
        case 4: r=0; g=0; b=255; break;
      }
      break;
    case BODY_PAGE_RECORDING:
      if (recordingInButtonMode) {
        switch(idx) {
          case 0: r=0; g=255; b=0; break;
          case 1: r=255; g=165; b=0; break;
          case 2: r=255; g=0; b=255; break;
          case 3: r=0; g=0; b=255; break;
        }
      } else { r=0; g=255; b=0; }
      break;
    case BODY_PAGE_SYSTEM_SETTINGS:
      switch(idx) {
        case 0: r=0; g=255; b=255; break;
        case 1: r=0; g=255; b=0; break;
        case 2: r=255; g=0; b=255; break;
        case 3: r=255; g=0; b=0; break;
        case 4: r=0; g=0; b=255; break;
      }
      break;
    case BODY_PAGE_TIME_SETTINGS:
      if (idx <= 4) { r=0; g=255; b=255; }
      else if (idx == 5) { r=0; g=255; b=0; }
      else { r=0; g=0; b=255; }
      break;
    case BODY_PAGE_FUNSCRIPT_SETTINGS:
      switch(idx) {
        case 0: r=0; g=255; b=0; break;
        case 1: r=255; g=0; b=0; break;
        case 2: r=0; g=0; b=255; break;
      }
      break;
    case BODY_PAGE_FORMAT_CONFIRM:
      switch(idx) {
        case 0: r=0; g=0; b=255; break;
        case 1: r=255; g=0; b=0; break;
      }
      break;
    case BODY_PAGE_PLAYBACK:
      switch(idx) {
        case 0: r=255; g=165; b=0; break;   // STOP: Oranje
        case 1: r=0; g=255; b=0; break;     // PLAY/PAUZE: Groen
        case 2: r=255; g=0; b=255; break;   // AI-ACTIE: Magenta
        case 3: r=0; g=255; b=255; break;   // Speed -: Cyaan
        case 4: r=0; g=255; b=255; break;   // Speed +: Cyaan
      }
      break;
    default: break;
  }
}

// Update encoder LED voor huidige menu state
void updateEncoderLEDForMenu() {
  if (!encoderPixelAvailable) return;
  
  if (bodyMenuMode == BODY_MODE_SENSORS && encoderActiveMainScreen) {
    switch(mainScreenButtonIdx) {
      case 0: setEncoderLED(255, 0, 0); break;
      case 1: setEncoderLED(0, 255, 0); break;
      case 2: setEncoderLED(0, 0, 255); break;
      case 3: setEncoderLED(255, 0, 255); break;
    }
    return;
  }
  
  if (bodyMenuMode == BODY_MODE_MENU) {
    uint8_t r, g, b;
    getButtonColor(bodyMenuPage, bodyMenuIdx, r, g, b);
    setEncoderLED(r, g, b);
  }
}

// Flash encoder LED helder voor selectie
void flashEncoderLEDForButton() {
  if (!encoderPixelAvailable) return;
  uint8_t r, g, b;
  
  if (bodyMenuMode == BODY_MODE_SENSORS && encoderActiveMainScreen) {
    switch(mainScreenButtonIdx) {
      case 0: r=255; g=0; b=0; break;
      case 1: r=0; g=255; b=0; break;
      case 2: r=0; g=0; b=255; break;
      case 3: r=255; g=0; b=255; break;
      default: r=255; g=255; b=255; break;
    }
  } else {
    getButtonColor(bodyMenuPage, bodyMenuIdx, r, g, b);
  }
  setEncoderLED(r, g, b, true);
}

// ðŸ”¥ NIEUW: Flush buffer naar SD kaart
void flushCSVBuffer() {
  if (bufferIndex == 0 || !csvFile) {
    return;  // Niks te flushen
  }
  
  Serial.printf("[CSV BUFFER] Flushing %d samples to SD...\n", bufferIndex);
  
  // Schrijf alle buffered regels in 1 keer
  for (int i = 0; i < bufferIndex; i++) {
    csvFile.println(csvBuffer[i]);
  }
  
  csvFile.flush();  // Force write naar SD
  
  Serial.printf("[CSV BUFFER] Flushed! Total samples: %d\n", csvSampleCount);
  
  // Reset buffer
  bufferIndex = 0;
  lastBufferFlush = millis();
}

void startCSVRecording() {
  if (!rtcAvailable) {
    Serial.println("[CSV] ERROR: RTC niet beschikbaar, kan geen bestand aanmaken");
    isRecording = false;
    return;
  }
  
  // Maak bestandsnaam met timestamp
  DateTime now = rtc.now();
  char filename[64];
  sprintf(filename, "/recordings/%02d-%02d - %02d-%02d-%02d.csv",
        now.hour(), now.minute(),        // Tijd: HH-MM
        now.day(), now.month(), now.year() % 100);  // Datum: DD-MM-YY        
  csvFilename = String(filename);
  
  // Maak recordings directory als die niet bestaat
  if (!SD_MMC.exists("/recordings")) {
    if (SD_MMC.mkdir("/recordings")) {
      Serial.println("[CSV] Created /recordings directory");
    } else {
      Serial.println("[CSV] ERROR: Could not create /recordings directory");
      isRecording = false;
      return;
    }
  }
  
  // Open bestand voor schrijven
  csvFile = SD_MMC.open(csvFilename.c_str(), FILE_WRITE);
  if (!csvFile) {
    Serial.printf("[CSV] ERROR: Could not create file: %s\n", csvFilename.c_str());
    isRecording = false;
    return;
  }
  
  // Schrijf CSV header
  csvFile.println("Tijd_s,Timestamp,BPM,Temp_C,GSR,Trust,Sleeve,Suction,Vibe,Zuig,Vacuum_mbar,Pause,SleevePos_%,SpeedStep,AI_Override");
  csvFile.flush();
  
  recordingStartTime = millis();
  csvSampleCount = 0;
  lastCSVWrite = millis();
  
  Serial.printf("[CSV] Recording STARTED: %s\n", csvFilename.c_str());
}

void stopCSVRecording() {
  // ðŸ”¥ NIEUW: Flush buffer voordat bestand sluiten
  flushCSVBuffer();

  if (csvFile) {
    csvFile.close();
    Serial.printf("[CSV] Recording STOPPED: %s (%u samples)\n", csvFilename.c_str(), csvSampleCount);
  }
  csvFilename = "";
  csvSampleCount = 0;

  // ðŸ”¥ NIEUW: Reset buffer
  bufferIndex = 0;
}

void updateCSVRecording() {
  if (!isRecording || !csvFile) return;
  
  uint32_t now = millis();
  if (now - lastCSVWrite < CSV_WRITE_INTERVAL) return;  // Nog geen tijd voor nieuwe sample
  
  lastCSVWrite = now;
  
  // Haal sensor data op
  ADS1115_SensorData sensorData = ads1115_getData();
  
  // Bereken tijd sinds start (in seconden)
  float elapsedTime = (now - recordingStartTime) / 1000.0f;
  
  // Maak timestamp string
  if (rtcAvailable) {
    DateTime rtcNow = rtc.now();
    char timestamp[32];
    sprintf(timestamp, "%04d-%02d-%02d_%02d:%02d:%02d",
            rtcNow.year(), rtcNow.month(), rtcNow.day(),
            rtcNow.hour(), rtcNow.minute(), rtcNow.second());
    
    // ðŸ”¥ NIEUW: Schrijf naar BUFFER in plaats van direct naar SD
    char csvLine[256];
    sprintf(csvLine, "%.1f,%s,%u,%.2f,%.1f,%.2f,%.2f,%.1f,%d,%d,%.1f,%d,%.0f,%u,%d",
            elapsedTime,           // Tijd sinds start
            timestamp,             // RTC timestamp
            sensorData.BPM,        // Hartslag
            sensorData.temperature, // Temperatuur
            sensorData.gsrSmooth,  // GSR
            trustSpeed,            // Trust snelheid
            sleeveSpeed,           // Sleeve snelheid
            suctionLevel,          // Suction level
            vibeOn ? 1 : 0,        // Vibe status
            zuigActive ? 1 : 0,    // Zuig status
            vacuumMbar,            // Vacuum mbar
            pauseActive ? 1 : 0,   // Pause status
            sleevePercentage,      // Sleeve positie %
            hoofdESPSpeedStep,     // Speed step
            aiOverruleActive ? 1 : 0);  // AI override
    
    csvBuffer[bufferIndex++] = String(csvLine);
    csvSampleCount++;
    
    // ðŸ”¥ NIEUW: Flush als buffer vol (60 samples = 1 minuut)
    if (bufferIndex >= SD_BUFFER_SIZE) {
      flushCSVBuffer();
    }
    
    // Status print (elke 10 samples)
    if (csvSampleCount % 10 == 0) {
      Serial.printf("[CSV] Sample %u: BPM=%u Temp=%.1f GSR=%.0f (buffered: %d/%d)\n",
                    csvSampleCount, sensorData.BPM, sensorData.temperature, 
                    sensorData.gsrSmooth, bufferIndex, SD_BUFFER_SIZE);
    }
  }
}

// Menu mode
enum AppMode { MODE_MAIN = 0, MODE_MENU = 1 };
static AppMode currentMode = MODE_MAIN;

// Extern menu state uit body_menu.cpp
extern BodyMenuMode bodyMenuMode;
extern BodyMenuPage bodyMenuPage;
extern int bodyMenuIdx;
extern bool bodyMenuEdit;

// Touch debounce
static uint32_t lastButtonTouch = 0;

// Sensor push timing (globaal zodat we het kunnen resetten)
static uint32_t lastSensorPush = 0;

// Scherm rotatie state (1 = normaal landscape, 3 = 180Â° gedraaid)
static uint8_t screenRotation = 1;

// Funscript mode (Aan/Uit) - extern beschikbaar voor menu
bool funscriptEnabled = false;

// ===== ESP-NOW Callback =====
static void onESPNowReceive(const esp_now_recv_info *info, const uint8_t *incomingData, int len) {
  if (len == sizeof(esp_now_receive_message_t)) {
    esp_now_receive_message_t message;
    memcpy(&message, incomingData, sizeof(message));
    
// Update machine parameters
    trustSpeed = message.trust;
    sleeveSpeed = message.sleeve;
    suctionLevel = message.suction;
    vibeOn = message.vibeOn;
    zuigActive = message.zuigActive;
    vacuumMbar = message.vacuumMbar;
    pauseActive = message.pauseActive;
    
    // DETECTEER PAUSE STATUS CHANGE
    static bool wasPaused = false;
    if (message.pauseActive && !wasPaused && aiOverruleActive) {
      // Pauze net geactiveerd EN AI is actief â†’ Emergency pause!
      Serial.println("[PAUSE] âš ï¸ Emergency pause detected!");

      levelBeforePause = message.currentSpeedStep;
      
      Serial.printf("[PAUSE] Was op Level %d\n", levelBeforePause);
      
      if (EMERGENCY_PAUSE_ROOD_SCHERM) {
        emergencyPauseActive = true;
      }
      
    }
    wasPaused = message.pauseActive;
    
    // Lube sync systeem
    if (message.lubeTrigger && !lubeTrigger) {
      lastLubeTriggerTime = millis();
      Serial.println("[LUBE SYNC] Nieuwe cyclus start!");
    }
    lubeTrigger = message.lubeTrigger;
    cyclusTijd = message.cyclusTijd;
    sleevePercentage = message.sleevePercentage;
    hoofdESPSpeedStep = message.currentSpeedStep;
    
    lastCommTime = millis();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMMAND HANDLING - Hooft ESP Commands
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Check command type
    if (strcmp(message.command, "STATUS_UPDATE") == 0) {
      // Normale status update - niks extra doen
    }
    else if (strcmp(message.command, "ORGASM_TRIGGER") == 0) {
      Serial.println("[CMD] âœ… ORGASM_TRIGGER ontvangen!");
  
      // AI stopt met overrides (geen commands naar Hooft ESP)
      // MAAR: sensors blijven lezen, CSV blijft loggen, ML blijft leren
      if (aiOverruleActive) {
        aiOverruleActive = false;
        Serial.println("[AI] Overrides PAUSED - monitoring blijft actief");
      }
  
      // TODO: Log event voor ML training
    }
    else if (strcmp(message.command, "FUNSCRIPT_ON") == 0) {
      funscriptEnabled = true;
      Serial.println("[CMD] âœ… Funscript ENABLED door Hooft ESP");
    }
    else if (strcmp(message.command, "FUNSCRIPT_OFF") == 0) {
      funscriptEnabled = false;
      Serial.println("[CMD] âœ… Funscript DISABLED door Hooft ESP");
    }
    else if (strcmp(message.command, "ORGASM_COMPLETE") == 0) {
      Serial.println("[CMD] âœ… ORGASM_COMPLETE - User drukte C knop");
      // TODO: AI berekent optimale cooldown tijd
      // TODO: Stuurt COOLDOWN_OVERRIDE naar Hooft ESP
    }  
    else if (strcmp(message.command, "COOLDOWN_COMPLETE") == 0) {
      Serial.println("[CMD] âœ… COOLDOWN_COMPLETE - hervat AI overrides");
  
      // AI hervat normale overrides
      if (!aiOverruleActive) {
        aiOverruleActive = true;
        Serial.println("[AI] Overrides RESUMED - AI mag weer ingrijpen");
      }
    }
    else {
      Serial.printf("[CMD] âš ï¸ Unknown command: %s\n", message.command);
    }
    
    Serial.printf("[ESP-NOW] RX: T:%.1f S:%.1f Su:%.1f V:%d Z:%d Vac:%.1f P:%d Lube:%d Cyc:%.1fs Pos:%.0f%% Step:%d Cmd:%s\n", 
                  trustSpeed, sleeveSpeed, suctionLevel, vibeOn, zuigActive, vacuumMbar,
                  pauseActive, lubeTrigger, cyclusTijd, sleevePercentage, hoofdESPSpeedStep, message.command);
  } else {
    Serial.printf("[ESP-NOW] RX SIZE MISMATCH: %d bytes\n", len);
  }
}

// ===== ESP-NOW Initialisatie =====
static bool initESPNow() {
  Serial.println("[ESP-NOW] Initializing...");
  Serial.printf("[ESP-NOW] Body MAC: %02X:%02X:%02X:%02X:%02X:%02X\n",
                bodyESP_MAC[0], bodyESP_MAC[1], bodyESP_MAC[2],
                bodyESP_MAC[3], bodyESP_MAC[4], bodyESP_MAC[5]);
  
  WiFi.mode(WIFI_STA);
  WiFi.setChannel(4);  // Kanaal 4 (sync met HoofdESP)
  
  if (esp_now_init() != ESP_OK) {
    Serial.println("[ESP-NOW] Init failed");
    return false;
  }
  
  // Registreer ontvangst callback
  esp_now_register_recv_cb(onESPNowReceive);
  
  // Voeg HoofdESP toe als peer
  esp_now_peer_info_t peerInfo;
  memset(&peerInfo, 0, sizeof(peerInfo));
  memcpy(peerInfo.peer_addr, hoofdESP_MAC, 6);
  peerInfo.channel = 4;
  peerInfo.encrypt = false;
  
  Serial.printf("[ESP-NOW] Adding HoofdESP: %02X:%02X:%02X:%02X:%02X:%02X\n",
                hoofdESP_MAC[0], hoofdESP_MAC[1], hoofdESP_MAC[2],
                hoofdESP_MAC[3], hoofdESP_MAC[4], hoofdESP_MAC[5]);
  
  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
    Serial.println("[ESP-NOW] Failed to add peer");
    return false;
  }
  
  Serial.println("[ESP-NOW] Initialized OK!");
  return true;
}

// ðŸ”¥ NIEUW: Voeg bericht toe aan retry queue
bool addToESPNowQueue(const esp_now_send_message_t& message) {
  if (queueCount >= ESPNOW_QUEUE_SIZE) {
    Serial.println("[ESP-NOW QUEUE] FULL - dropping oldest message");
    // Overschrijf oudste (head)
    queueHead = (queueHead + 1) % ESPNOW_QUEUE_SIZE;
    queueCount--;
  }
  
  // Voeg toe aan tail
  espNowQueue[queueTail].message = message;
  espNowQueue[queueTail].timestamp = millis();
  espNowQueue[queueTail].retryCount = 0;
  espNowQueue[queueTail].inUse = true;
  
  queueTail = (queueTail + 1) % ESPNOW_QUEUE_SIZE;
  queueCount++;
  
  Serial.printf("[ESP-NOW QUEUE] Added message (queue: %d/%d)\n", queueCount, ESPNOW_QUEUE_SIZE);
  return true;
}

// ðŸ”¥ NIEUW: Verwerk retry queue
void processESPNowQueue() {
  if (queueCount == 0 || !espNowInitialized) return;
  
  ESPNowQueueItem* item = &espNowQueue[queueHead];
  
  // Check of het tijd is voor retry
  if (millis() - item->timestamp < RETRY_DELAY_MS) {
    return;  // Nog niet tijd voor retry
  }
  
  // Probeer te verzenden
  esp_err_t result = esp_now_send(hoofdESP_MAC, (uint8_t*)&item->message, sizeof(item->message));
  
  if (result == ESP_OK) {
    // Success! Verwijder uit queue
    Serial.printf("[ESP-NOW QUEUE] Retry SUCCESS (attempt %d)\n", item->retryCount + 1);
    item->inUse = false;
    queueHead = (queueHead + 1) % ESPNOW_QUEUE_SIZE;
    queueCount--;
  } else {
    // Failed - increment retry
    item->retryCount++;
    item->timestamp = millis();  // Reset timer voor volgende retry
    
    if (item->retryCount >= MAX_RETRIES) {
      // Max retries bereikt - drop message
      Serial.printf("[ESP-NOW QUEUE] Max retries reached - dropping message\n");
      item->inUse = false;
      queueHead = (queueHead + 1) % ESPNOW_QUEUE_SIZE;
      queueCount--;
    } else {
      Serial.printf("[ESP-NOW QUEUE] Retry %d/%d failed\n", item->retryCount, MAX_RETRIES);
    }
  }
}

// ===== ESP-NOW Verzend Functie =====
// Extern beschikbaar voor MultiFunPlayer client
bool sendESPNowMessage(float newTrust, float newSleeve, bool overruleActive, const char* command, uint8_t stressLevel = 0, bool vibeOn = false, bool zuigenOn = false) {
  if (!espNowInitialized) return false;
  
  esp_now_send_message_t message;
  memset(&message, 0, sizeof(message));
  
  message.newTrust = newTrust;
  message.newSleeve = newSleeve;
  message.overruleActive = overruleActive;
  message.stressLevel = stressLevel;
  message.vibeOn = vibeOn;
  message.zuigenOn = zuigenOn;
  strncpy(message.command, command, sizeof(message.command) - 1);
  
  esp_err_t result = esp_now_send(hoofdESP_MAC, (uint8_t *)&message, sizeof(message));
  
  if (result == ESP_OK) {
    Serial.printf("[ESP-NOW] TX: T:%.1f S:%.1f O:%d Stress:%d Cmd:%s\n",
                  newTrust, newSleeve, overruleActive, stressLevel, command);
    return true;
  } else {
    // ðŸ”¥ NIEUW: Bij failure â†’ toevoegen aan retry queue
    Serial.printf("[ESP-NOW] TX FAILED: %d - adding to retry queue\n", result);
    addToESPNowQueue(message);
    return false;  // Direct send failed, maar wordt ge-retry'd
  }
}

// ===== RTC Tijd Opslaan Functie (voor menu) =====
bool saveRTCTime(int year, int month, int day, int hour, int minute) {
  if (!rtcAvailable) {
    Serial.println("[RTC] ERROR: RTC not available!");
    return false;
  }
  
  Serial.printf("[RTC] Saving time: %04d-%02d-%02d %02d:%02d:00\n",
                year, month, day, hour, minute);
  
  rtc.adjust(DateTime(year, month, day, hour, minute, 0));
  
  // Verify dat tijd opgeslagen is
  delay(100);  // Kleine delay voor RTC write
  DateTime now = rtc.now();
  Serial.printf("[RTC] Verified time: %04d-%02d-%02d %02d:%02d:%02d\n",
                now.year(), now.month(), now.day(),
                now.hour(), now.minute(), now.second());
  
  return true;
}

// ===== SD Kaart Format Functie (voor menu) =====
bool formatSDCard() {
  Serial.println("\n========================================");
  Serial.println("[SD FORMAT] Starting SD card format...");
  Serial.println("[SD FORMAT] WARNING: This will erase ALL data!");
  Serial.println("========================================\n");
  
  // Check of SD kaart beschikbaar is
  uint8_t cardType = SD_MMC.cardType();
  if (cardType == CARD_NONE) {
    Serial.println("[SD FORMAT] ERROR: No SD card attached!");
    return false;
  }
  
  Serial.println("[SD FORMAT] SD card detected, starting delete...");
  
  // Verwijder alle bestanden en mappen recursief
  int deletedFiles = 0;
  int deletedDirs = 0;
  
  // Helper functie om recursief te verwijderen
  std::function<void(const char*)> deleteRecursive = [&](const char* dirname) {
    File root = SD_MMC.open(dirname);
    if (!root) {
      Serial.printf("[SD FORMAT] Failed to open: %s\n", dirname);
      return;
    }
    if (!root.isDirectory()) {
      root.close();
      return;
    }
    
    File file = root.openNextFile();
    while (file) {
      String path = String(dirname) + "/" + String(file.name());
      
      if (file.isDirectory()) {
        Serial.printf("[SD FORMAT] Dir: %s\n", path.c_str());
        deleteRecursive(path.c_str());  // Recursief
        if (SD_MMC.rmdir(path.c_str())) {
          Serial.printf("[SD FORMAT] Deleted dir: %s\n", path.c_str());
          deletedDirs++;
        }
      } else {
        Serial.printf("[SD FORMAT] File: %s\n", path.c_str());
        if (SD_MMC.remove(path.c_str())) {
          Serial.printf("[SD FORMAT] Deleted: %s\n", path.c_str());
          deletedFiles++;
        } else {
          Serial.printf("[SD FORMAT] FAILED to delete: %s\n", path.c_str());
        }
      }
      
      file = root.openNextFile();
    }
    root.close();
  };
  
  // Start met root directory
  deleteRecursive("/");
  
  Serial.println("\n========================================");
  Serial.printf("[SD FORMAT] Format complete!\n");
  Serial.printf("[SD FORMAT] Deleted %d files and %d directories\n", deletedFiles, deletedDirs);
  Serial.println("[SD FORMAT] AI model in ESP32 flash is SAFE");
  Serial.println("========================================\n");
  
  return true;
}

// ===== Scherm Rotatie Toggle Functie (voor menu) =====
void toggleScreenRotation() {
  // Toggle tussen rotatie 1 (normaal) en 3 (180Â° gedraaid)
  if (screenRotation == 1) {
    screenRotation = 3;
  } else {
    screenRotation = 1;
  }
  
  // Pas rotatie toe op display
  body_gfx->setRotation(screenRotation);
  
  // Clear scherm en herteken alles
  body_gfx->fillScreen(0x0000);
  
  // Force menu redraw
  extern void bodyMenuForceRedraw();
  bodyMenuForceRedraw();
  
  Serial.printf("[SCREEN] Rotation changed to: %d (%s)\n", 
                screenRotation, (screenRotation == 1) ? "Normal" : "180 degrees");
}

void touchCallback(TPoint point, TEvent e) {
  // Track touch state om duplicate TouchEnd events te voorkomen
  static bool wasTouched = false;
  
  // Bij TouchStart/Tap: markeer als touched
  if (e == TEvent::Tap || e == TEvent::TouchStart) {
    wasTouched = true;
    return;  // Nog niet verwerken
  }
  
  // Bij TouchEnd: alleen verwerken als er eerst een touch was
  if (e == TEvent::TouchEnd) {
    if (!wasTouched) {
      return;  // Negeer duplicate TouchEnd zonder voorafgaande touch
    }
    wasTouched = false;  // Reset voor volgende touch
  } else {
    return;  // Andere events negeren
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EMERGENCY PAUSE RESUME - ALTIJD EERST CHECKEN!
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  if (emergencyPauseActive) {
    // Check emergency touch enabled
    if (!touchEmergencyEnabled) {
      Serial.println("[PAUSE] Touch disabled for emergency - use encoder!");
      return;  // Touch disabled, moet encoder gebruiken
    }
    
    Serial.println("[PAUSE] Touch detected - resuming session");
    
    // Start warm-up sequence (als enabled)
    if (EMERGENCY_WARMUP_ENABLED) {
      warmupActive = true;
      warmupStartTime = millis();
      Serial.printf("[WARMUP] Starting %dms warm-up to Level %d\n", 
                    WARMUP_DURATION_MS, levelBeforePause);
    }
    
    emergencyPauseActive = false;
    emergencyPauseScreenDrawn = false;
    setEncoderLEDOff();  // Stop knipperen
    
    // Stuur RESUME naar Hooft ESP
    sendESPNowMessage(0, 0, false, "RESUME_SESSION", 0, false, false);
    
    // Herstel normaal scherm
    body_gfx4_clear();
    body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
    //body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive);
    
    return;  // Stop hier, verwerk geen andere touches
  }

  // Raw coordinaten (touch is native 320x480 portrait)
  int16_t rawX = point.x;
  int16_t rawY = point.y;
  
  int16_t x, y;
  
  #if USE_MANUAL_MAPPING
    // ===== MANUAL MODE: Volledige controle =====
    x = rawX;
    y = rawY;
    
    // SWAP X en Y
    #if MANUAL_SWAP_XY
      int16_t temp = x;
      x = y;
      y = temp;
    #endif
    
    // Basis FLIP voor rotatie 1 (normaal)
    #if MANUAL_FLIP_X
      x = 480 - 1 - x;
    #endif
    
    #if MANUAL_FLIP_Y
      y = 320 - 1 - y;
    #endif
    
    // Extra flip voor rotatie 3 (180Â° gedraaid)
    if (screenRotation == 3) {
      x = 480 - 1 - x;
      y = 320 - 1 - y;
    }
  
  #else
    // ===== AUTO MODE: Gebruik rotatie =====
    #if TOUCH_ROTATION == 0
      // 0Â° - Portrait (native)
      x = rawX;
      y = rawY;
      
    #elif TOUCH_ROTATION == 1
      // 90Â° - Landscape (USB rechts) - WORKING COMBINATIE
      // Equivalent: SWAP_XY=1, FLIP_X=0, FLIP_Y=1
      x = rawY;
      y = 320 - 1 - rawX;
      
    #elif TOUCH_ROTATION == 2
      // 180Â° - Portrait (ondersteboven)
      x = 320 - 1 - rawX;
      y = 480 - 1 - rawY;
      
    #elif TOUCH_ROTATION == 3
      // 270Â° - Landscape (USB links)
      x = 480 - 1 - rawY;
      y = rawX;
      
    #else
      #error "TOUCH_ROTATION must be 0, 1, 2, or 3"
    #endif
    
    // Serial output UITGESCHAKELD (zie sensor debug in loop)
    // Serial.printf("RAW: x=%d, y=%d -> ROT%d: x=%d, y=%d (event=%d)\n", 
    //               rawX, rawY, TOUCH_ROTATION, x, y, (int)e);
  #endif
  
  // Clamp binnen scherm grenzen (480x320 landscape)
  if (x < 0) x = 0;
  if (x >= 480) x = 479;
  if (y < 0) y = 0;
  if (y >= 320) y = 319;
  
  touchX = x;
  touchY = y;
  touchDetected = true;
  
  // Simpele debounce: negeer touches binnen 300ms
  if (millis() - lastButtonTouch < 300) {
    return;
  }
  
  // ===== CHECK MENU KNOP EERST (werkt in beide modes) =====
  // SKIP tijdens playback - playback heeft eigen touch handling
  extern BodyMenuPage bodyMenuPage;
  bool isInPlayback = (bodyMenuPage == BODY_PAGE_PLAYBACK);
  
  // MENU knop gebied: x tussen 239-351, y tussen 280-315
  if (!isInPlayback && y >= 280 && y < 315 && x >= 239 && x < 351) {
    lastButtonTouch = millis();
    
    // Toggle tussen MAIN en MENU mode
    if (currentMode == MODE_MAIN) {
      currentMode = MODE_MENU;
      menuActive = true;
      bodyMenuMode = BODY_MODE_MENU;  // Activeer menu mode
      bodyMenuPage = BODY_PAGE_MAIN;  // Start bij hoofdmenu
      bodyMenuIdx = 0;  // Reset selectie
      bodyMenuForceRedraw();  // Force onmiddellijke hertekening
      Serial.println("[MENU] Entering menu mode");
    } else {
      currentMode = MODE_MAIN;
      menuActive = false;
      bodyMenuMode = BODY_MODE_SENSORS;  // Niet meer gebruikt, maar blijft voor compatibiliteit
      
      // ðŸ”¥ NIEUW: Reset rendering pause (kan nog aan staan vanaf popup)
      g4_pauseRendering = false;

      // Volledige hertekening van body_gfx4 scherm
      body_gfx4_clear();  // Clear menu EN teken frame
      body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
      //body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive);
      
      // Force onmiddellijke sensor update zodat grafieken zichtbaar worden
      lastSensorPush = 0;  // Reset timer (wordt gedeclareerd in loop)
      
      Serial.println("[MENU] Back to main screen (body_gfx4)");
    }
    return;  // Stop hier, knop is afgehandeld
  }
  
  // ===== MENU MODE TOUCH HANDLING =====
  if (currentMode == MODE_MENU) {
    lastButtonTouch = millis();
    bodyMenuHandleTouch(x, y, true);  // Stuur touch door naar menu systeem
    return;  // Menu verwerkt de touch, stop hier
  }
  
  if (y >= 280 && y < 315) {  // Binnen knop hoogte
    lastButtonTouch = millis();
    
    if (x >= 5 && x < 117) {
      // REC knop - toggle recording
      isRecording = !isRecording;
      
      if (isRecording) {
        startCSVRecording();  // Start nieuwe recording
      } else {
        stopCSVRecording();   // Stop huidige recording
      }
      
      body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
      //body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive);
      Serial.printf("[BUTTON] REC %s\n", isRecording ? "ON" : "OFF");
    }
    else if (x >= 122 && x < 234) {
      // PLAY knop - open Recording menu
      currentMode = MODE_MENU;
      menuActive = true;
      bodyMenuMode = BODY_MODE_MENU;
      bodyMenuPage = BODY_PAGE_RECORDING;  // Direct naar Recording menu
      bodyMenuIdx = 0;
      bodyMenuForceRedraw();
      Serial.println("[BUTTON] PLAY - Opening Recording menu");
    }
    else if (x >= 356 && x < 475) {
      // AI knop
      aiOverruleActive = !aiOverruleActive;
      body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
      //body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive);
      Serial.printf("[BUTTON] AI %s\n", aiOverruleActive ? "ON" : "OFF");
    }
  }
}


// ===== ENCODER HANDLER =====
void handleEncoderInput() {
  if (!encoderAvailable) return;
  
  static uint32_t lastEncoderRead = 0;
  static bool lastButtonState = false;
  static int32_t lastPosition = 0;
  static uint32_t buttonPressStart = 0;
  static uint32_t lastClickTime = 0;
  static bool waitingForDoubleClick = false;
  
  if (millis() - lastEncoderRead < 50) return;  // 50ms polling
  lastEncoderRead = millis();
  
  // Lees encoder
  int32_t newPosition = encoder.getEncoderPosition();
  int32_t delta = newPosition - lastPosition;
  bool buttonPressed = !encoder.digitalRead(24);  // Active LOW
  
  // ===== HOOFDSCHERM MODE =====
  if (currentMode == MODE_MAIN) {
    // Button press detectie
    if (buttonPressed && !lastButtonState) {
      buttonPressStart = millis();
      if (encoderActiveMainScreen) {
        flashEncoderLEDForButton();  // LED 100% bij indrukken
      }
    }
    
    // Button release detectie
    if (!buttonPressed && lastButtonState) {
      uint32_t pressDuration = millis() - buttonPressStart;
      
      // ENCODER INACTIEF: Check voor activatie of double-click
      if (!encoderActiveMainScreen) {
        if (pressDuration >= 1500) {
          // 2 sec hold = Activeer encoder
          encoderActiveMainScreen = true;
          mainScreenButtonIdx = 0;
          body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
          updateEncoderLEDForMenu();  // LED aan met knop kleur
          Serial.println("[ENCODER] Main screen activated");
        } else {
          // Kort drukken = Check voor double-click (AI toggle)
          if (waitingForDoubleClick && (millis() - lastClickTime < 800)) {
            // DOUBLE CLICK = Direct AI toggle
            aiOverruleActive = !aiOverruleActive;
            if (aiOverruleActive) {
              setEncoderLED(255, 0, 255, true);  // Fel paars als AI AAN
            } else {
              setEncoderLEDOff();  // LED uit als AI UIT
            }
            body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
            Serial.printf("[ENCODER] AI toggled: %s\n", aiOverruleActive ? "ON" : "OFF");
            waitingForDoubleClick = false;
          } else {
            // Eerste klik - wacht op tweede
            waitingForDoubleClick = true;
            lastClickTime = millis();
          }
        }
      }
       // ENCODER ACTIEF: Selecteer button
       else {
        if (mainScreenButtonIdx == 0) {
          // REC toggle
          isRecording = !isRecording;
          if (isRecording) startCSVRecording();
          else stopCSVRecording();
          body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
          Serial.printf("[ENCODER] REC: %s\n", isRecording ? "ON" : "OFF");
        } else if (mainScreenButtonIdx == 1) {
          // PLAY - open menu
          currentMode = MODE_MENU;
          menuActive = true;
          bodyMenuMode = BODY_MODE_MENU;
          bodyMenuPage = BODY_PAGE_RECORDING;
          bodyMenuIdx = 0;
          recordingInButtonMode = false;  // Reset naar bestand mode
          bodyMenuForceRedraw();
          Serial.println("[ENCODER] -> Recording menu");
        } else if (mainScreenButtonIdx == 2) {
          // MENU - open menu
          currentMode = MODE_MENU;
          menuActive = true;
          bodyMenuMode = BODY_MODE_MENU;
          bodyMenuPage = BODY_PAGE_MAIN;
          bodyMenuIdx = 0;
          bodyMenuForceRedraw();
          updateEncoderLEDForMenu();  // LED aan met menu kleur
          Serial.println("[ENCODER] -> Main menu");
        } else if (mainScreenButtonIdx == 3) {
          // AI toggle + DEACTIVEER encoder
          aiOverruleActive = !aiOverruleActive;
          encoderActiveMainScreen = false;
          setEncoderLEDOff();  // LED uit
          body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
          Serial.printf("[ENCODER] AI: %s (deactivated)\n", aiOverruleActive ? "ON" : "OFF");
        }
      }
    }
    
    // Reset double-click timer
    if (waitingForDoubleClick && (millis() - lastClickTime > 800)) {
      waitingForDoubleClick = false;
    }
    
    // DRAAIEN (alleen als encoder actief)
    if (encoderActiveMainScreen && delta != 0) {
      if (delta > 0) {
        mainScreenButtonIdx--;  // Rechts = links
      } else {
        mainScreenButtonIdx++;  // Links = rechts
      }
      
      // Wrap around (4 buttons: 0-3)
      if (mainScreenButtonIdx < 0) mainScreenButtonIdx = 3;
      if (mainScreenButtonIdx > 3) mainScreenButtonIdx = 0;
      
      body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
      updateEncoderLEDForMenu();  // LED update met nieuwe kleur
      Serial.printf("[ENCODER] Button: %d\n", mainScreenButtonIdx);
      lastPosition = newPosition;
    }
  }
  // ===== MENU MODE ===== (bestaande code blijft)
  else if (currentMode == MODE_MENU) {
    // Button press detectie - LED fel
    if (buttonPressed && !lastButtonState) {
      if (!aiSettingsEditMode && !sensorSettingsEditMode && !timeSettingsEditMode) {
        flashEncoderLEDForButton();  // LED 100% bij indrukken
      }
    }
    
    // DRAAIEN
    if (delta != 0) {
      int maxItems = 6;
      if (bodyMenuPage == BODY_PAGE_MAIN) maxItems = 6;
      else if (bodyMenuPage == BODY_PAGE_SENSOR_CAL) maxItems = 4;  // 4 items + TERUG
      else if (bodyMenuPage == BODY_PAGE_AI_SETTINGS) {
        if (aiSettingsEditMode) {
          maxItems = 0;  // Geen scrollen tijdens edit mode
        } else {
          maxItems = 8;  // 6 params + 3 knoppen (0-8)
        }
      }
      else if (bodyMenuPage == BODY_PAGE_ML_TRAINING) maxItems = 4;  // 4 items + TERUG
      else if (bodyMenuPage == BODY_PAGE_SENSOR_SETTINGS) {
        if (sensorSettingsEditMode) {
          maxItems = 0;  // Geen scrollen tijdens edit mode
        } else {
          maxItems = 7;  // 6 params + 2 knoppen (0-7)
        }
      }
      //else if (bodyMenuPage == BODY_PAGE_RECORDING) maxItems = 3;  // 4 buttons: 0,1,2,3
      else if (bodyMenuPage == BODY_PAGE_RECORDING) {
        extern int csvCount;
        if (!recordingInButtonMode) {
          maxItems = max(0, csvCount - 1);  // FASE 1: Alle bestanden
        } else {
          maxItems = 3;  // FASE 2: 4 knoppen (PLAY, DELETE, AI, TERUG)
        }
      }
      else if (bodyMenuPage == BODY_PAGE_SYSTEM_SETTINGS) maxItems = 4;  // 4 items + TERUG
      else if (bodyMenuPage == BODY_PAGE_FUNSCRIPT_SETTINGS) maxItems = 2;  // AAN, UIT, TERUG
      else if (bodyMenuPage == BODY_PAGE_FORMAT_CONFIRM) maxItems = 1;  // ANNULEREN, FORMATTEER
      else if (bodyMenuPage == BODY_PAGE_PLAYBACK) maxItems = 4;  // STOP, PAUZE, AI-ACTIE, Speed-, Speed+
      else if (bodyMenuPage == BODY_PAGE_TIME_SETTINGS) {
      if (timeSettingsEditMode) {
        maxItems = 0;  // Geen scrollen tijdens edit mode
        } else {
          maxItems = 6;  // 5 params + 2 knoppen (0-6)
       }
      }
      // SPECIAL: Time Settings edit mode - waarde +/-
      if (bodyMenuPage == BODY_PAGE_TIME_SETTINGS && timeSettingsEditMode && delta != 0) {
        int stepSize = 1;
        
        // +/- waarde
        if (delta > 0) {  // Rechts = omlaag
          switch(timeSettingsEditingParam) {
            case 0: editYear = max(2024, editYear - stepSize); break;
            case 1: editMonth = max(1, editMonth - stepSize); break;
            case 2: editDay = max(1, editDay - stepSize); break;
            case 3: editHour = max(0, editHour - stepSize); break;
            case 4: editMinute = max(0, editMinute - stepSize); break;
          }
        } else {  // Links = omhoog
          switch(timeSettingsEditingParam) {
            case 0: editYear = min(2099, editYear + stepSize); break;
            case 1: editMonth = min(12, editMonth + stepSize); break;
            case 2: editDay = min(31, editDay + stepSize); break;
            case 3: editHour = min(23, editHour + stepSize); break;
            case 4: editMinute = min(59, editMinute + stepSize); break;
          }
        }
        
        Serial.printf("[ENCODER] Time param %d: %d\n", timeSettingsEditingParam,
                      timeSettingsEditingParam == 0 ? editYear :
                      timeSettingsEditingParam == 1 ? editMonth :
                      timeSettingsEditingParam == 2 ? editDay :
                      timeSettingsEditingParam == 3 ? editHour : editMinute);
        
        // LED gradient: paars(0) -> rood(+) / blauw(-)
        int currentVal = timeSettingsEditingParam == 0 ? editYear :
                         timeSettingsEditingParam == 1 ? editMonth :
                         timeSettingsEditingParam == 2 ? editDay :
                         timeSettingsEditingParam == 3 ? editHour : editMinute;
        int gradientDelta = (currentVal - timeParamBackup[timeSettingsEditingParam]) * 10;
        setEncoderLEDGradient(gradientDelta);
        
        bodyMenuForceRedraw();
        lastPosition = newPosition;
        return;  // Skip normale scroll logica
      }
      // SPECIAL: Sensor Settings edit mode - waarde +/-
      if (bodyMenuPage == BODY_PAGE_SENSOR_SETTINGS && sensorSettingsEditMode && delta != 0) {
        float stepSize = 1.0f;  // Default step
        
        // Bepaal step size per parameter
        if (sensorSettingsEditingParam == 1 || sensorSettingsEditingParam == 2 || sensorSettingsEditingParam == 5) {
          stepSize = 0.01f;  // Offset/Smoothing: 0.01 stappen
        } else if (sensorSettingsEditingParam == 0) {
          stepSize = 1000.0f;  // Beat threshold: 1000 stappen
        } else if (sensorSettingsEditingParam == 3) {
          stepSize = 10.0f;  // GSR baseline: 10 stappen
        } else if (sensorSettingsEditingParam == 4) {
          stepSize = 0.1f;  // GSR sensitivity: 0.1 stappen
        }
        
        // +/- waarde
        if (delta > 0) {  // Rechts = omlaag
          switch(sensorSettingsEditingParam) {
            case 0: sensorEdit.beatThreshold = max(10000.0f, sensorEdit.beatThreshold - stepSize); break;
            case 1: sensorEdit.tempOffset = max(-10.0f, sensorEdit.tempOffset - stepSize); break;
            case 2: sensorEdit.tempSmoothing = max(0.0f, sensorEdit.tempSmoothing - stepSize); break;
            case 3: sensorEdit.gsrBaseline = max(0.0f, sensorEdit.gsrBaseline - stepSize); break;
            case 4: sensorEdit.gsrSensitivity = max(0.0f, sensorEdit.gsrSensitivity - stepSize); break;
            case 5: sensorEdit.gsrSmoothing = max(0.0f, sensorEdit.gsrSmoothing - stepSize); break;
          }
        } else {  // Links = omhoog
          switch(sensorSettingsEditingParam) {
            case 0: sensorEdit.beatThreshold = min(100000.0f, sensorEdit.beatThreshold + stepSize); break;
            case 1: sensorEdit.tempOffset = min(10.0f, sensorEdit.tempOffset + stepSize); break;
            case 2: sensorEdit.tempSmoothing = min(1.0f, sensorEdit.tempSmoothing + stepSize); break;
            case 3: sensorEdit.gsrBaseline = min(2000.0f, sensorEdit.gsrBaseline + stepSize); break;
            case 4: sensorEdit.gsrSensitivity = min(5.0f, sensorEdit.gsrSensitivity + stepSize); break;
            case 5: sensorEdit.gsrSmoothing = min(1.0f, sensorEdit.gsrSmoothing + stepSize); break;
          }
        }
        
        Serial.printf("[ENCODER] Sensor param %d: %.2f\n", sensorSettingsEditingParam,
                      sensorSettingsEditingParam == 0 ? sensorEdit.beatThreshold :
                      sensorSettingsEditingParam == 1 ? sensorEdit.tempOffset :
                      sensorSettingsEditingParam == 2 ? sensorEdit.tempSmoothing :
                      sensorSettingsEditingParam == 3 ? sensorEdit.gsrBaseline :
                      sensorSettingsEditingParam == 4 ? sensorEdit.gsrSensitivity : sensorEdit.gsrSmoothing);
        
        // LED gradient: paars(0) -> rood(+) / blauw(-)
        float currentVal = sensorSettingsEditingParam == 0 ? sensorEdit.beatThreshold :
                           sensorSettingsEditingParam == 1 ? sensorEdit.tempOffset :
                           sensorSettingsEditingParam == 2 ? sensorEdit.tempSmoothing :
                           sensorSettingsEditingParam == 3 ? sensorEdit.gsrBaseline :
                           sensorSettingsEditingParam == 4 ? sensorEdit.gsrSensitivity : sensorEdit.gsrSmoothing;
        float diff = currentVal - sensorParamBackup[sensorSettingsEditingParam];
        // Scale per parameter: 10 stappen = volle gradient
        int gradientDelta;
        switch(sensorSettingsEditingParam) {
          case 0: gradientDelta = (int)(diff / 100); break;   // Beat: stap 1000
          case 1: gradientDelta = (int)(diff * 1000); break;  // TempOffset: stap 0.01
          case 2: gradientDelta = (int)(diff * 1000); break;  // TempSmooth: stap 0.01
          case 3: gradientDelta = (int)(diff); break;         // GSR Base: stap 10
          case 4: gradientDelta = (int)(diff * 100); break;   // GSR Sens: stap 0.1
          case 5: gradientDelta = (int)(diff * 1000); break;  // GSR Smooth: stap 0.01
          default: gradientDelta = (int)(diff * 10); break;
        }
        setEncoderLEDGradient(gradientDelta);
        
        bodyMenuForceRedraw();
        lastPosition = newPosition;
        return;  // Skip normale scroll logica
      }
      // SPECIAL: AI Settings edit mode - waarde +/-
      if (bodyMenuPage == BODY_PAGE_AI_SETTINGS && aiSettingsEditMode && delta != 0) {
        //extern AISettingsData aiSettings;
        float stepSize = 1.0f;  // Default step
        
        // Bepaal step size per parameter
        if (aiSettingsEditingParam == 4 || aiSettingsEditingParam == 5) {
          stepSize = 0.1f;  // Response/Autonomy: 0.1 stappen
        }
        
        // +/- waarde
        if (delta > 0) {  // Rechts = omlaag
          switch(aiSettingsEditingParam) {
            case 0: aiSettings.autonomyLevel = max(0.0f, aiSettings.autonomyLevel - stepSize); break;
            case 1: aiSettings.hrLow = max(40.0f, aiSettings.hrLow - stepSize); break;
            case 2: aiSettings.hrHigh = max(60.0f, aiSettings.hrHigh - stepSize); break;
            case 3: aiSettings.tempMax = max(30.0f, aiSettings.tempMax - stepSize); break;
            case 4: aiSettings.gsrMax = max(100.0f, aiSettings.gsrMax - stepSize); break;
            case 5: aiSettings.responseRate = max(0.0f, aiSettings.responseRate - stepSize); break;
          }
        } else {  // Links = omhoog
          switch(aiSettingsEditingParam) {
            case 0: aiSettings.autonomyLevel = min(100.0f, aiSettings.autonomyLevel + stepSize); break;
            case 1: aiSettings.hrLow = min(100.0f, aiSettings.hrLow + stepSize); break;
            case 2: aiSettings.hrHigh = min(200.0f, aiSettings.hrHigh + stepSize); break;
            case 3: aiSettings.tempMax = min(50.0f, aiSettings.tempMax + stepSize); break;
            case 4: aiSettings.gsrMax = min(5000.0f, aiSettings.gsrMax + stepSize); break;
            case 5: aiSettings.responseRate = min(10.0f, aiSettings.responseRate + stepSize); break;
          }
        }
        
        Serial.printf("[ENCODER] AI param %d: %.1f\n", aiSettingsEditingParam, 
                      aiSettingsEditingParam == 0 ? aiSettings.autonomyLevel :
                      aiSettingsEditingParam == 1 ? aiSettings.hrLow :
                      aiSettingsEditingParam == 2 ? aiSettings.hrHigh :
                      aiSettingsEditingParam == 3 ? aiSettings.tempMax :
                      aiSettingsEditingParam == 4 ? aiSettings.gsrMax : aiSettings.responseRate);
        
        // LED gradient: paars(0) -> rood(+) / blauw(-)
        float currentVal = aiSettingsEditingParam == 0 ? aiSettings.autonomyLevel :
                           aiSettingsEditingParam == 1 ? aiSettings.hrLow :
                           aiSettingsEditingParam == 2 ? aiSettings.hrHigh :
                           aiSettingsEditingParam == 3 ? aiSettings.tempMax :
                           aiSettingsEditingParam == 4 ? aiSettings.gsrMax : aiSettings.responseRate;
        float diff = currentVal - aiParamBackup[aiSettingsEditingParam];
        // Scale per parameter: 10 stappen = volle gradient
        int gradientDelta;
        switch(aiSettingsEditingParam) {
          case 0: gradientDelta = (int)(diff * 10); break;  // Autonomy: 0-100, stap 1
          case 1: gradientDelta = (int)(diff * 10); break;  // HR Low: stap 1
          case 2: gradientDelta = (int)(diff * 10); break;  // HR High: stap 1
          case 3: gradientDelta = (int)(diff * 10); break;  // Temp Max: stap 1
          case 4: gradientDelta = (int)(diff / 10); break;  // GSR Max: stap 100
          case 5: gradientDelta = (int)(diff * 100); break; // Response: stap 0.1
          default: gradientDelta = (int)(diff * 10); break;
        }
        setEncoderLEDGradient(gradientDelta);
        
        bodyMenuForceRedraw();
        lastPosition = newPosition;
        return;  // Skip normale scroll logica
      }

      // straks nieuwe
      if (delta > 0) {
        bodyMenuIdx--;
      } else {
        bodyMenuIdx++;
      }
      
      if (bodyMenuIdx < 0) bodyMenuIdx = maxItems;
      if (bodyMenuIdx > maxItems) bodyMenuIdx = 0;
      
      // Force playback screen redraw voor encoder highlights
      if (bodyMenuPage == BODY_PAGE_PLAYBACK) {
        extern bool playbackScreenDrawn;
        playbackScreenDrawn = false;
      }
      
      bodyMenuForceRedraw();
      updateEncoderLEDForMenu();  // LED update met nieuwe kleur
      Serial.printf("[ENCODER MENU] Index: %d\n", bodyMenuIdx);
      lastPosition = newPosition;
    }
    
    // BUTTON RELEASED
    if (!buttonPressed && lastButtonState) {
      if (bodyMenuPage == BODY_PAGE_MAIN) {
        if (bodyMenuIdx == 0) {
          bodyMenuPage = BODY_PAGE_ML_TRAINING;
          bodyMenuIdx = 0;
        } else if (bodyMenuIdx == 1) {
          bodyMenuPage = BODY_PAGE_RECORDING;
          bodyMenuIdx = 0;  // Start bij eerste bestand
          recordingInButtonMode = false;  // Reset naar bestand mode
          Serial.println("[ENCODER] -> Recording");
        } else if (bodyMenuIdx == 2) {
          bodyMenuPage = BODY_PAGE_AI_SETTINGS;
          bodyMenuIdx = 0;
          //aiSettingsInButtonMode = false;
          aiSettingsEditMode = false;
  
          // Backup originele waarden
          //extern AISettingsData aiSettings;
          aiParamBackup[0] = aiSettings.autonomyLevel;
          aiParamBackup[1] = aiSettings.hrLow;
          aiParamBackup[2] = aiSettings.hrHigh;
          aiParamBackup[3] = aiSettings.tempMax;
          aiParamBackup[4] = aiSettings.gsrMax;
          aiParamBackup[5] = aiSettings.responseRate;
  
          // Reset modified flags
          for (int i = 0; i < 6; i++) aiParamModified[i] = false;
  
          Serial.println("[ENCODER] -> AI Settings");

        } else if (bodyMenuIdx == 3) {
          bodyMenuPage = BODY_PAGE_SENSOR_CAL;
          bodyMenuIdx = 0;
        } else if (bodyMenuIdx == 4) {
          bodyMenuPage = BODY_PAGE_SENSOR_SETTINGS;
          bodyMenuIdx = 0;
          sensorSettingsEditMode = false;
  
          // Backup originele waarden
          sensorParamBackup[0] = sensorEdit.beatThreshold;
          sensorParamBackup[1] = sensorEdit.tempOffset;
          sensorParamBackup[2] = sensorEdit.tempSmoothing;
          sensorParamBackup[3] = sensorEdit.gsrBaseline;
          sensorParamBackup[4] = sensorEdit.gsrSensitivity;
          sensorParamBackup[5] = sensorEdit.gsrSmoothing;
  
          // Reset modified flags
          for (int i = 0; i < 6; i++) sensorParamModified[i] = false;
          
          Serial.println("[ENCODER] -> Sensor Settings");
        } else if (bodyMenuIdx == 5) {
          bodyMenuPage = BODY_PAGE_SYSTEM_SETTINGS;
          bodyMenuIdx = 0;
        } else if (bodyMenuIdx == 6) {
          currentMode = MODE_MAIN;
           menuActive = false;
           bodyMenuMode = BODY_MODE_SENSORS;
           encoderActiveMainScreen = false;
           setEncoderLEDOff();  // LED uit bij terug naar main
  
           g4_pauseRendering = false;
           body_gfx4_clear();
           body_gfx4_drawButtons(isRecording, isPlaying, menuActive, aiOverruleActive, false, encoderActiveMainScreen ? mainScreenButtonIdx : -1);
           lastSensorPush = 0;
  
           Serial.println("[ENCODER] -> Back to main (deactivated)");
        }
      }
      //W3}
      else if (bodyMenuPage == BODY_PAGE_SENSOR_CAL) {
        // Sensor Calibration: 4 items + TERUG (index 4)
        if (bodyMenuIdx >= 0 && bodyMenuIdx <= 3) {
          // Start calibratie: 0=Alle, 1=GSR, 2=Temp, 3=Hart
          extern void startCalibration(uint8_t type);
          startCalibration(bodyMenuIdx);
          Serial.printf("[ENCODER] Start calibration: %d\n", bodyMenuIdx);
        } else if (bodyMenuIdx == 4) {
          // TERUG
          bodyMenuPage = BODY_PAGE_MAIN;
          bodyMenuIdx = 0;
          Serial.println("[ENCODER] -> Back to main menu");
        }
      }
      else if (bodyMenuPage == BODY_PAGE_AI_SETTINGS) {
        if (bodyMenuIdx < 6) {
          // PARAMETERS (0-5)
          if (!aiSettingsEditMode) {
            // Start editing
            aiSettingsEditMode = true;
            aiSettingsEditingParam = bodyMenuIdx;
            setEncoderLED(255, 0, 255, true);  // Fel paars bij start edit
            Serial.printf("[ENCODER] Editing param: %d\n", bodyMenuIdx);
          } else {
            // Exit edit â†’ markeer rood
            aiSettingsEditMode = false;
            aiParamModified[aiSettingsEditingParam] = true;
            aiSettingsEditingParam = -1;
            updateEncoderLEDForMenu();  // Terug naar menu kleur
            Serial.println("[ENCODER] Param saved (marked RED)");
          }
        } else {
          // KNOPPEN (6-8)
          int btnIdx = bodyMenuIdx - 6;
          if (btnIdx == 0) {
            // AI AAN toggle
            bodyMenuHandleTouch(90, 250, true);
            Serial.println("[ENCODER] AI toggled");
          } else if (btnIdx == 1) {
            // Opslaan
            bodyMenuHandleTouch(210, 250, true);
            for (int i = 0; i < 6; i++) aiParamModified[i] = false;  // Reset rood
            Serial.println("[ENCODER] Saved to EEPROM");
          } else if (btnIdx == 2) {
            // TERUG - restore
            aiSettings.autonomyLevel = aiParamBackup[0];
            aiSettings.hrLow = aiParamBackup[1];
            aiSettings.hrHigh = aiParamBackup[2];
            aiSettings.tempMax = aiParamBackup[3];
            aiSettings.gsrMax = aiParamBackup[4];
            aiSettings.responseRate = aiParamBackup[5];
            
            bodyMenuPage = BODY_PAGE_MAIN;
            bodyMenuIdx = 0;
            aiSettingsEditMode = false;
            Serial.println("[ENCODER] Back (changes discarded)");
          }
        }
      }
      else if (bodyMenuPage == BODY_PAGE_ML_TRAINING) {     
        // ML Training: 4 items + TERUG
        if (bodyMenuIdx == 0) {
          // Toggle recording
          isRecording = !isRecording;
          if (isRecording) startCSVRecording();
          else stopCSVRecording();
          Serial.printf("[ENCODER] Recording: %s\n", isRecording ? "ON" : "OFF");
        } else if (bodyMenuIdx == 1) {
          // Model Trainen
          Serial.println("[ENCODER] Model Trainen - TODO");
        } else if (bodyMenuIdx == 2) {
          // AI Annotatie
          Serial.println("[ENCODER] AI Annotatie - TODO");
        } else if (bodyMenuIdx == 3) {
          // Model Manager
          Serial.println("[ENCODER] Model Manager - TODO");
        } else if (bodyMenuIdx == 4) {
          // TERUG
          bodyMenuPage = BODY_PAGE_MAIN;
          bodyMenuIdx = 0;
          Serial.println("[ENCODER] -> Back to main menu");
        }
      }
      else if (bodyMenuPage == BODY_PAGE_SENSOR_SETTINGS) {
        if (bodyMenuIdx < 6) {
          // PARAMETERS (0-5)
          if (!sensorSettingsEditMode) {
            // Start editing
            sensorSettingsEditMode = true;
            sensorSettingsEditingParam = bodyMenuIdx;
            setEncoderLED(255, 0, 255, true);  // Fel paars bij start edit
            Serial.printf("[ENCODER] Editing sensor param: %d\n", bodyMenuIdx);
          } else {
            // Exit edit â†’ markeer rood
            sensorSettingsEditMode = false;
            sensorParamModified[sensorSettingsEditingParam] = true;
            sensorSettingsEditingParam = -1;
            updateEncoderLEDForMenu();  // Terug naar menu kleur
            Serial.println("[ENCODER] Sensor param saved (marked RED)");
          }
        } else {
          // KNOPPEN (6-7)
          int btnIdx = bodyMenuIdx - 6;
          if (btnIdx == 0) {
            // Opslaan - blijf in menu
            bodyMenuHandleTouch(330, 250, true);
            for (int i = 0; i < 6; i++) sensorParamModified[i] = false;  // Reset rood
            bodyMenuPage = BODY_PAGE_SENSOR_SETTINGS;  // Force terug naar menu
            bodyMenuIdx = 0;  // Reset cursor
            Serial.println("[ENCODER] Sensor settings saved, staying in menu");
          } else if (btnIdx == 1) {
            // TERUG - restore
            sensorEdit.beatThreshold = sensorParamBackup[0];
            sensorEdit.tempOffset = sensorParamBackup[1];
            sensorEdit.tempSmoothing = sensorParamBackup[2];
            sensorEdit.gsrBaseline = sensorParamBackup[3];
            sensorEdit.gsrSensitivity = sensorParamBackup[4];
            sensorEdit.gsrSmoothing = sensorParamBackup[5];
            
            bodyMenuPage = BODY_PAGE_MAIN;
            bodyMenuIdx = 0;
            sensorSettingsEditMode = false;
            Serial.println("[ENCODER] Back (sensor changes discarded)");
          }
      }
      }
      else if (bodyMenuPage == BODY_PAGE_SYSTEM_SETTINGS) {
        // System Settings: 4 items + TERUG
        if (bodyMenuIdx == 0) {
          // Scherm Rotatie toggle
          extern void toggleScreenRotation();
          toggleScreenRotation();
          Serial.println("[ENCODER] Screen rotation toggled");
        } else if (bodyMenuIdx == 1) {
          // Funscript Settings
          bodyMenuPage = BODY_PAGE_FUNSCRIPT_SETTINGS;
          bodyMenuIdx = 0;
          Serial.println("[ENCODER] -> Funscript Settings");
        } else if (bodyMenuIdx == 2) {
          // Format SD bevestiging
          bodyMenuPage = BODY_PAGE_FORMAT_CONFIRM;
          bodyMenuIdx = 0;
          Serial.println("[ENCODER] -> Format SD confirmation");
        } else if (bodyMenuIdx == 3) {
          // Tijd Instellen
          bodyMenuPage = BODY_PAGE_TIME_SETTINGS;
          bodyMenuIdx = 0;
          timeSettingsEditMode = false;
          
          // Backup originele waarden
          timeParamBackup[0] = editYear;
          timeParamBackup[1] = editMonth;
          timeParamBackup[2] = editDay;
          timeParamBackup[3] = editHour;
          timeParamBackup[4] = editMinute;
          
          // Reset modified flags
          for (int i = 0; i < 5; i++) timeParamModified[i] = false;
          
          Serial.println("[ENCODER] -> Time Settings");
        } else if (bodyMenuIdx == 4) {
          // TERUG
          bodyMenuPage = BODY_PAGE_MAIN;
          bodyMenuIdx = 0;
          Serial.println("[ENCODER] -> Back to main menu");
        }
      }
      else if (bodyMenuPage == BODY_PAGE_FUNSCRIPT_SETTINGS) {
        // Funscript Settings: AAN, UIT, TERUG
        extern bool funscriptEnabled;
        if (bodyMenuIdx == 0) {
          // AAN
          funscriptEnabled = true;
          Serial.println("[ENCODER] Funscript enabled");
        } else if (bodyMenuIdx == 1) {
          // UIT
          funscriptEnabled = false;
          Serial.println("[ENCODER] Funscript disabled");
        } else if (bodyMenuIdx == 2) {
          // TERUG naar System Settings
          bodyMenuPage = BODY_PAGE_SYSTEM_SETTINGS;
          bodyMenuIdx = 0;
          Serial.println("[ENCODER] -> Back to System Settings");
        }
      }
      else if (bodyMenuPage == BODY_PAGE_FORMAT_CONFIRM) {
        // Format SD bevestiging: ANNULEREN, FORMATTEER
        if (bodyMenuIdx == 0) {
          // ANNULEREN - terug naar System Settings
          bodyMenuPage = BODY_PAGE_SYSTEM_SETTINGS;
          bodyMenuIdx = 0;
          Serial.println("[ENCODER] Format cancelled");
        } else if (bodyMenuIdx == 1) {
          // FORMATTEER
          bodyMenuHandleTouch(310, 250, true);  // Klik op FORMATTEER knop
          Serial.println("[ENCODER] Formatting SD card...");
        }
      }
      else if (bodyMenuPage == BODY_PAGE_TIME_SETTINGS) {
        if (bodyMenuIdx < 5) {
          // PARAMETERS (0-4)
          if (!timeSettingsEditMode) {
            // Start editing
            timeSettingsEditMode = true;
            timeSettingsEditingParam = bodyMenuIdx;
            setEncoderLED(255, 0, 255, true);  // Fel paars bij start edit
            Serial.printf("[ENCODER] Editing time param: %d\n", bodyMenuIdx);
          } else {
            // Exit edit â†’ markeer rood
            timeSettingsEditMode = false;
            timeParamModified[timeSettingsEditingParam] = true;
            timeSettingsEditingParam = -1;
            updateEncoderLEDForMenu();  // Terug naar menu kleur
            Serial.println("[ENCODER] Time param saved (marked RED)");
          }
        } else {
          // KNOPPEN (5-6)
          int btnIdx = bodyMenuIdx - 5;
          if (btnIdx == 0) {
            // Opslaan - blijf in menu
            bodyMenuHandleTouch(110, 250, true);
            for (int i = 0; i < 5; i++) timeParamModified[i] = false;  // Reset rood
            bodyMenuPage = BODY_PAGE_TIME_SETTINGS;  // Force terug naar menu
            bodyMenuIdx = 0;  // Reset cursor
            Serial.println("[ENCODER] Time saved, staying in menu");
          } else if (btnIdx == 1) {
            // TERUG - restore
            editYear = timeParamBackup[0];
            editMonth = timeParamBackup[1];
            editDay = timeParamBackup[2];
            editHour = timeParamBackup[3];
            editMinute = timeParamBackup[4];
            
            bodyMenuPage = BODY_PAGE_SYSTEM_SETTINGS;
            bodyMenuIdx = 0;
            timeSettingsEditMode = false;
            Serial.println("[ENCODER] Back (time changes discarded)");
          }
        }
      }
      else if (bodyMenuPage == BODY_PAGE_RECORDING) {
        extern int csvCount;
        extern int selectedRecordingFile;
        
        if (!recordingInButtonMode) {
          // FASE 1: Bestand selecteren
          selectedRecordingFile = bodyMenuIdx;
          recordingInButtonMode = true;
          bodyMenuIdx = 0;  // Start bij PLAY
          bodyMenuForceRedraw();
          Serial.printf("[ENCODER] File selected: %d, switched to buttons\n", selectedRecordingFile);
        } else {
          // FASE 2: Knop actie
          if (bodyMenuIdx == 0) {
            // PLAY - direct uitvoeren
            extern int csvCount;
            extern String csvFiles[];
            extern void startPlayback(const char* filename);
            if (selectedRecordingFile >= 0 && selectedRecordingFile < csvCount) {
              char playFile[64];
              strncpy(playFile, csvFiles[selectedRecordingFile].c_str(), 63);
              playFile[63] = '\0';
              startPlayback(playFile);
              Serial.printf("[ENCODER] PLAY: %s\n", playFile);
            } else {
              Serial.println("[ENCODER] PLAY: Geen bestand geselecteerd!");
            }
          //if (bodyMenuIdx == 0) {
            // PLAY - direct uitvoeren
            //extern int csvCount;
            //extern String csvFiles[];
            //extern char selectedPlaybackFile[];
            //extern void startPlayback(const char* filename);
            //if (selectedRecordingFile >= 0 && selectedRecordingFile < csvCount) {
              //strncpy(selectedPlaybackFile, csvFiles[selectedRecordingFile].c_str(), 63);
              //selectedPlaybackFile[63] = '\0';
              //startPlayback(selectedPlaybackFile);
              //Serial.printf("[ENCODER] PLAY: %s\n", selectedPlaybackFile);
            //} else {
              //Serial.println("[ENCODER] PLAY: Geen bestand geselecteerd!");
            //}
          } else if (bodyMenuIdx == 1) {
            // DELETE - direct uitvoeren
            extern int csvCount;
            extern String csvFiles[];
            if (selectedRecordingFile >= 0 && selectedRecordingFile < csvCount) {
              String filepath = "/recordings/" + csvFiles[selectedRecordingFile];
              if (SD_MMC.remove(filepath.c_str())) {
                Serial.printf("[ENCODER] Deleted: %s\n", filepath.c_str());
                csvCount = -1;  // Trigger rescan
                selectedRecordingFile = -1;
                recordingInButtonMode = false;
                bodyMenuForceRedraw();
              }
            }
          } else if (bodyMenuIdx == 2) {
            // AI analyze
            Serial.println("[ENCODER] AI analyze - TODO");
          } else if (bodyMenuIdx == 3) {
            // TERUG - reset naar bestand mode
            selectedRecordingFile = -1;
            recordingInButtonMode = false;
            bodyMenuPage = BODY_PAGE_MAIN;
            bodyMenuIdx = 0;
            Serial.println("[ENCODER] -> Back (reset to file mode)");
          }
        }
      }
      else if (bodyMenuPage == BODY_PAGE_PLAYBACK) {
        // Playback knoppen: 0=STOP, 1=PAUZE, 2=AI-ACTIE, 3=Speed-, 4=Speed+
        extern void stopPlayback();
        extern bool isPlaybackPaused;
        extern float playbackSpeed;
        
        if (bodyMenuIdx == 0) {
          // STOP
          stopPlayback();
          bodyMenuPage = BODY_PAGE_RECORDING;
          bodyMenuIdx = 0;
          Serial.println("[ENCODER] PLAYBACK STOP");
        } else if (bodyMenuIdx == 1) {
          // PLAY/PAUZE toggle
          isPlaybackPaused = !isPlaybackPaused;
          Serial.printf("[ENCODER] PLAYBACK %s\n", isPlaybackPaused ? "PAUSED" : "PLAYING");
        } else if (bodyMenuIdx == 2) {
          // AI-ACTIE - open stress popup
          bodyMenuHandleTouch(400, 290, true);  // Trigger AI-ACTIE touch zone
          Serial.println("[ENCODER] AI-ACTIE");
        } else if (bodyMenuIdx == 3) {
          // Speed -
          playbackSpeed = max(10.0f, playbackSpeed - 10.0f);
          Serial.printf("[ENCODER] Speed: %.0f%%\n", playbackSpeed);
        } else if (bodyMenuIdx == 4) {
          // Speed +
          playbackSpeed = min(200.0f, playbackSpeed + 10.0f);
          Serial.printf("[ENCODER] Speed: %.0f%%\n", playbackSpeed);
        }
      }
      // nieuwe straks
      bodyMenuForceRedraw();
      // LED update na menu actie (maar niet als we in edit mode zitten)
      if (!aiSettingsEditMode && !sensorSettingsEditMode && !timeSettingsEditMode) {
        updateEncoderLEDForMenu();
      }
    }
  }
  
  lastButtonState = buttonPressed;
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  // ðŸ”¥ NIEUW: Watchdog timer (10 sec timeout)
  Serial.println("[WDT] Enabling watchdog timer...");
  esp_task_wdt_config_t wdt_config = {
    .timeout_ms = 10000,      // 10 seconden
    .idle_core_mask = 0,      // Niet monitoren van idle cores
    .trigger_panic = true     // Reset bij timeout
  };
  esp_task_wdt_init(&wdt_config);
  esp_task_wdt_add(NULL);       // Add current thread
  Serial.println("[WDT] Watchdog active - will reset if frozen for >10 sec!");

  Serial.println("\n\n=== SC01 Plus Touch Test ===");
  
  // ===== Display initialisatie =====
  gfx->begin();
  gfx->setRotation(1);  // Landscape

  //u8g2_fonts.begin(*gfx);
  //Serial.println("[U8G2] Font renderer initialized");
  
  // Backlight aan
  pinMode(GFX_BL, OUTPUT);
  digitalWrite(GFX_BL, HIGH);
  
  // // Rood scherm = bezig met initialisatie - UITGESCHAKELD
  // gfx->fillScreen(0xF800);
  // gfx->setTextColor(0xFFFF);
  // gfx->setTextSize(2);
  // gfx->setCursor(10, 10);
  // gfx->println("Touch Test - Initializing...");
  
  Serial.println("[DISPLAY] 480x320 initialized");
  
  // ===== Touch initialisatie =====
  Wire.begin(TOUCH_SDA, TOUCH_SCL);
  Wire.setClock(400000);
  
  Serial.println("[TOUCH] Starting I2C...");
  
  // FT6X36 zonder interrupt (polling mode)
  ts = new FT6X36(&Wire, TOUCH_INT);
  
  if (ts->begin()) {
    Serial.println("[TOUCH] FT6336U initialized OK!");
    
    // Registreer callback
    ts->registerTouchHandler(touchCallback);
    
    // // Groen scherm = OK - UITGESCHAKELD: direct naar body_gfx4
    // gfx->fillScreen(0x07E0);
    // gfx->setCursor(10, 10);
    // gfx->setTextColor(0x0000);  // Zwarte tekst
    // gfx->println("Touch Controller OK!");
    // gfx->setCursor(10, 40);
    // gfx->println("Raak scherm aan...");
    // gfx->setCursor(10, 70);
    // gfx->println("Witte pixels = touch");
    // gfx->setCursor(10, 100);
    // #if USE_MANUAL_MAPPING
    //   gfx->printf("MANUAL: S%d FX%d FY%d", MANUAL_SWAP_XY, MANUAL_FLIP_X, MANUAL_FLIP_Y);
    // #else
    //   gfx->printf("Rotation: %d", TOUCH_ROTATION);
    // #endif
    
  } else {
    Serial.println("[TOUCH] ERROR: FT6336U not found!");
    // gfx->fillScreen(0xF800);  // Rood = fout
    // gfx->setCursor(10, 40);
    // gfx->println("ERROR: Touch not found!");
    // 
    // // Blijf rood
    // gfx->setCursor(10, 40);
    // gfx->println("ERROR: Touch not found!");
    // gfx->setCursor(10, 70);
    // gfx->println("Check I2C wiring:");
    // gfx->setCursor(10, 100);
    // gfx->println("SDA=GPIO6, SCL=GPIO5");
    
    while(1) delay(1000);  // Stop hier - check Serial Monitor
  }
  
  // ===== I2C Sensors Test (Wire1 - GPIO 10/11) =====
  Serial.println("\n[I2C] Starting Wire1 on GPIO 10/11...");
  Wire1.begin(SENSOR_SDA, SENSOR_SCL);
  Wire1.setClock(400000);
  
  // int yPos = 130;  // Display uitgeschakeld - alleen Serial logging
  
  // Test 1: ADS1115 (0x48) - gebruik ads1115_begin() functie
  Serial.println("[I2C] Testing ADS1115 (0x48)...");
  if (ads1115_begin()) {
    Serial.println("[I2C] ADS1115 OK via ads1115_begin()!");
    adsAvailable = true;
    
    // Laad kalibratie uit ESP32 EEPROM
    Serial.println("[CONFIG] Loading calibration from ESP32 EEPROM...");
    loadSensorConfig();  // Laadt en past toe op ADS1115
    
    // gfx->setCursor(10, yPos);
    // gfx->setTextColor(0x07E0);
    // gfx->println("ADS1115: OK");
  } else {
    Serial.println("[I2C] ADS1115 NOT found");
    // gfx->setCursor(10, yPos);
    // gfx->setTextColor(0xF800);
    // gfx->println("ADS1115: FAIL");
  }
  // yPos += 30;
  
  // Test 2: RTC DS3231 (0x68)
  Serial.println("[I2C] Testing RTC DS3231 (0x68)...");
  if (rtc.begin(&Wire1)) {
    Serial.println("[I2C] RTC DS3231 OK!");
    rtcAvailable = true;
    
    // Check of RTC tijd verloren heeft
    if (rtc.lostPower()) {
      Serial.println("[RTC] Power was lost - setting default time");
      // Zet standaard tijd: 1 januari 2024, 00:00:00
      rtc.adjust(DateTime(2024, 1, 1, 0, 0, 0));
    }
    
    // Toon huidige tijd
    DateTime now = rtc.now();
    Serial.printf("[RTC] Current time: %02d/%02d/%04d %02d:%02d:%02d\n",
                  now.day(), now.month(), now.year(),
                  now.hour(), now.minute(), now.second());
  } else {
    Serial.println("[I2C] RTC DS3231 NOT found");
    rtcAvailable = false;
  }
  // yPos += 30;
  
  // Test 3: I2C EEPROM (0x50) - AT24C02 256 bytes
  Serial.println("[I2C] Testing EEPROM (0x50 - A0/A1/A2=GND)...");
  Wire1.beginTransmission(EEPROM_ADDR);
  if (Wire1.endTransmission() == 0) {
    Serial.println("[I2C] EEPROM OK!");
    eepromAvailable = true;
    // gfx->setCursor(10, yPos);
    // gfx->setTextColor(0x07E0);
    // gfx->println("EEPROM: OK");
  } else {
    Serial.println("[I2C] EEPROM NOT found");
    // gfx->setCursor(10, yPos);
    // gfx->setTextColor(0xF800);
    // gfx->println("EEPROM: FAIL");
  }
  
  // ===== EEPROM Test (write/read/clear) =====
  if (eepromAvailable) {
    Serial.println("\n[EEPROM] Testing write/read/clear...");
    
    // Test data
    uint8_t testData[] = {0xAA, 0x55, 0x12, 0x34};
    uint8_t addr = 0;
    
    // Write test
    Serial.print("[EEPROM] Writing: ");
    for (int i = 0; i < 4; i++) {
      Wire1.beginTransmission(EEPROM_ADDR);
      Wire1.write(addr + i);  // Address
      Wire1.write(testData[i]);  // Data
      Wire1.endTransmission();
      delay(5);  // EEPROM write delay
      Serial.printf("0x%02X ", testData[i]);
    }
    Serial.println();
    
    delay(10);
    
    // Read test
    Serial.print("[EEPROM] Reading: ");
    bool readOK = true;
    for (int i = 0; i < 4; i++) {
      Wire1.beginTransmission(EEPROM_ADDR);
      Wire1.write(addr + i);  // Set address
      Wire1.endTransmission();
      Wire1.requestFrom(EEPROM_ADDR, 1);
      if (Wire1.available()) {
        uint8_t readByte = Wire1.read();
        Serial.printf("0x%02X ", readByte);
        if (readByte != testData[i]) readOK = false;
      } else {
        Serial.print("ERR ");
        readOK = false;
      }
    }
    Serial.println(readOK ? "- MATCH!" : "- MISMATCH!");
    
    // Clear test
    Serial.print("[EEPROM] Clearing: ");
    for (int i = 0; i < 4; i++) {
      Wire1.beginTransmission(EEPROM_ADDR);
      Wire1.write(addr + i);
      Wire1.write(0xFF);  // Cleared byte
      Wire1.endTransmission();
      delay(5);
    }
    Serial.println("Done");
    
    Serial.println("[EEPROM] Test PASSED - EEPROM fully functional!");
  }
  
  // Test 4: Rotary Encoder (0x36)
  Serial.println("[I2C] Testing Rotary Encoder (0x36)...");
  if (encoder.begin(ENCODER_ADDR)) {
    Serial.println("[I2C] Rotary Encoder OK!");
    encoderAvailable = true;
  
    // Configureer encoder
    encoder.pinMode(24, INPUT_PULLUP);  // Encoder button
    encoder.setGPIOInterrupts((uint32_t)1 << 24, 1);  // Enable button interrupt
    encoder.enableEncoderInterrupt();
  
    // Reset positie naar 0
    encoder.setEncoderPosition(0);
    encoderPosition = 0;
  
    Serial.println("[ENCODER] Configured and ready!");
    
    // NeoPixel op encoder board initialiseren
    if (encoderPixel.begin(ENCODER_ADDR)) {
      encoderPixelAvailable = true;
      encoderPixel.setBrightness(255);
      encoderPixel.setPixelColor(0, 0);  // Uit bij start
      encoderPixel.show();
      Serial.println("[ENCODER] NeoPixel ready!");
    } else {
      Serial.println("[ENCODER] NeoPixel FAILED!");
    }
  } else {
    Serial.println("[I2C] Rotary Encoder NOT found");
    encoderAvailable = false;
  }

  // ===== SD Card Initialisatie (SD_MMC mode) =====
  Serial.println("\n[SD CARD] Initializing SD_MMC...");
  SD_MMC.setPins(39, 40, 38);  // CLK, CMD, D0
  if (SD_MMC.begin("/sdcard", true)) {  // 1-bit mode
    Serial.println("[SD CARD] Initialized OK!");
  } else {
    Serial.println("[SD CARD] Init failed - recording won't work");
  }
  
  // ===== ESP-NOW Initialisatie =====
  Serial.println("\n[ESP-NOW] Starting initialization...");
  espNowInitialized = initESPNow();
  
  if (espNowInitialized) {
    Serial.println("[ESP-NOW] Ready for communication!");
    // Test bericht versturen
    sendESPNowMessage(1.0f, 1.0f, false, "HEARTBEAT", 0, false, false);
  } else {
    Serial.println("[ESP-NOW] FAILED - continuing without ESP-NOW");
  }
  
  // ===== Stress Manager Initialisatie =====
  Serial.println("\n[AI] Initializing Stress Manager...");
  extern AdvancedStressManager stressManager;
  stressManager.begin();
  Serial.println("[AI] Stress Manager ready!");

  // ===== Body GFX4 Initialisatie =====
  Serial.println("\n[BODY_GFX4] Initializing graphics system...");
  body_gfx4_begin();
  body_gfx4_setLabel(G4_HART, "Hart");
  body_gfx4_setLabel(G4_HUID, "Huid");
  body_gfx4_setLabel(G4_TEMP, "Temp");
  body_gfx4_setLabel(G4_ADEMHALING, "Adem");
  body_gfx4_setLabel(G4_HOOFDESP, "Trust");
  body_gfx4_setLabel(G4_ZUIGEN, "Zuigen");
  body_gfx4_setLabel(G4_TRIL, "Vibe");
  Serial.println("[BODY_GFX4] Graphics system ready!");
  
  // ===== Menu Systeem Initialisatie =====
  Serial.println("\n[MENU] Initializing menu system...");
  bodyMenuInit();
  Serial.println("[MENU] Menu system ready!");
  
  // ===== MultiFunPlayer Initialisatie =====
  Serial.println("\n[MFP] Initializing MultiFunPlayer client...");
  setupMultiFunPlayer();  // Zie body_config.h voor configuratie
  Serial.println("[MFP] Client ready! Toggle Funscript in System Settings.");
  
  // ===== Touch Toggle States Laden =====
  prefs.begin("touch_cfg", false);
  touchMenuEnabled = prefs.getBool("touch_menu", TOUCH_MENU_ENABLED);
  touchParamsEnabled = prefs.getBool("touch_params", TOUCH_PARAMS_ENABLED);
  touchEmergencyEnabled = prefs.getBool("touch_emerg", TOUCH_EMERGENCY_ENABLED);
  prefs.end();
  Serial.printf("[SETUP] Touch states loaded: Menu=%d Params=%d Emergency=%d\n", 
                touchMenuEnabled, touchParamsEnabled, touchEmergencyEnabled);
  
  Serial.println("\n[BODY] System ready!");
  Serial.println("[BODY] Touch knoppen: REC, PLAY, MENU, AI");
  Serial.println("[BODY] ESP-NOW: heartbeat elke 5 seconden");
  Serial.println("[BODY] 7 sensor grafieken actief");
  Serial.println("[BODY] Funscript: Toggle in Menu > Instellingen > Funscript");
  Serial.println("========================================\n");
}

void loop() {

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EMERGENCY PAUSE SCREEN - Teken in main loop (niet in callback!)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  if (emergencyPauseActive && !emergencyPauseScreenDrawn) {
    Serial.println("[PAUSE] Drawing red screen with smooth fonts...");

    body_gfx->fillScreen(0xF800);
    body_gfx->setTextColor(0xFFFF);
  
    // "Nood Pauze" - grote smooth font
    body_gfx->setFont(&FreeSansBold18pt7b);
    body_gfx->setCursor(140, 100);
    body_gfx->print("Nood Pauze");
  
    // "Raak scherm aan" - kleinere smooth font
    body_gfx->setFont(&FreeSans12pt7b);
    body_gfx->setCursor(150, 150);
    body_gfx->print("Raak scherm aan");
  
    // Reset naar default font
    body_gfx->setFont();
  
    emergencyPauseScreenDrawn = true;
  }

  // Emergency pause LED knipperen (fel rood, 200ms interval)
  if (emergencyPauseActive && encoderPixelAvailable) {
    if (millis() - lastEmergencyBlink > 200) {
      lastEmergencyBlink = millis();
      emergencyBlinkState = !emergencyBlinkState;
      if (emergencyBlinkState) {
        setEncoderLED(255, 0, 0, true);  // Fel rood
      } else {
        setEncoderLEDOff();
      }
    }
  }

  /*
  if (emergencyPauseActive && !emergencyPauseScreenDrawn) {
    Serial.println("[PAUSE] Drawing red screen...");
  
    body_gfx->fillScreen(0xF800);  // Rood
    body_gfx->setTextColor(0xFFFF);
  
    // "Nood Pauze" - grote letters, gecentreerd
    body_gfx->setTextSize(4);
    body_gfx->setCursor(65, 100);
    body_gfx->println("Nood Pauze");
  
    // "Raak scherm aan" - kleinere letters
    body_gfx->setTextSize(2);
    body_gfx->setCursor(100, 180);
    body_gfx->println("Raak scherm aan");
  
    emergencyPauseScreenDrawn = true;
  }
  */

  esp_task_wdt_reset();  // ðŸ”¥ Reset watchdog elke loop iteratie

  // ðŸ§ª TEST: Uncomment om watchdog te testen (ESP reset na 10 sec)
   //static bool tested = false;
   //if (!tested && millis() > 5000) {
     //Serial.println("[TEST] Freezing loop to trigger watchdog...");
     //while(1); // Freeze
     //tested = true;
   //}

  // Debug: bevestig dat loop draait
  static bool firstLoop = true;
  if (firstLoop) {
    Serial.println("\n[LOOP] Loop started!");
    firstLoop = false;
  }
  
  // POLLING MODE: handmatig touch data lezen
  if (ts) {
    ts->processTouch();  // Lees I2C
    ts->loop();          // Verwerk events
  }
  
  // Touch wordt nu afgehandeld in touchCallback (body_gfx4 knoppen)
  if (touchDetected) {
    touchDetected = false;
  }
  
  // Check of playback actief is
  bool isPlayback = (bodyMenuPage == BODY_PAGE_PLAYBACK);
  
  // ===== MENU MODE POLLING (als menu actief is OF playback actief) =====
  if (currentMode == MODE_MENU || isPlayback) {
    bodyMenuTick();  // Update menu display en playback overlay
    // Menu touch handling gebeurt al in touchCallback
  }
  // MAIN MODE: body_gfx4 grafieken worden automatisch ge-update via pushSample()
  
  // ===== ECHTE SENSOR DATA (zie config.h voor interval) =====
  // ALLEEN in MAIN mode (NIET tijdens playback - playback gebruikt CSV data)
  //if (currentMode == MODE_MAIN && !isPlayback && millis() - lastSensorPush > SENSOR_INTERVAL_MS) {
    if (currentMode == MODE_MAIN && !isPlayback && !emergencyPauseActive && millis() - lastSensorPush > SENSOR_INTERVAL_MS) {
    if (adsAvailable) {
      // Lees alle ADS1115 sensoren
      ads1115_readAll();
      ADS1115_SensorData sensorData = ads1115_getData();
      
      // Push echte sensor data naar grafieken
      body_gfx4_pushSample(G4_HART, sensorData.BPM);                // Hart: BPM
      body_gfx4_pushSample(G4_HUID, sensorData.gsrSmooth / GSR_SCHAAL_FACTOR);  // GSR: zie config.h
      body_gfx4_pushSample(G4_TEMP, sensorData.temperature);        // Temp: Â°C
      body_gfx4_pushSample(G4_ADEMHALING, sensorData.breathValue);  // Ademhaling: 0-100%

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // AI STRESS MANAGER UPDATE & WARM-UP
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      if (warmupActive) {
        // WARM-UP NA EMERGENCY PAUSE
        uint32_t elapsed = millis() - warmupStartTime;
  
        if (elapsed >= WARMUP_DURATION_MS) {
          warmupActive = false;
          Serial.println("[WARMUP] Complete! Returning to normal AI control");
        } else {
          float progress = elapsed / (float)WARMUP_DURATION_MS;
          //uint8_t currentWarmupLevel = WARMUP_START_LEVEL + (uint8_t)(progress * (levelBeforePause - WARMUP_START_LEVEL));
          uint8_t currentWarmupLevel = WARMUP_START_LEVEL + (uint8_t)(progress * (levelBeforePause - WARMUP_START_LEVEL) + 0.5f);
  
          // Level naar speed mapping
          const float levelSpeeds[8] = {0.1, 0.4, 0.6, 0.8, 1.0, 1.3, 1.6, 2.0};
          float trustSpeed = levelSpeeds[currentWarmupLevel];
  
          sendESPNowMessage(
            trustSpeed,
            trustSpeed,
            true,
            "AI_WARMUP",  // â† Verander naar AI_WARMUP!
            currentWarmupLevel,
            WARMUP_VIBE_ENABLED,
            WARMUP_SUCTION_ENABLED
          );
  
          // Debug output (elke seconde)
          static uint32_t lastWarmupDebug = 0;
          if (millis() - lastWarmupDebug > 1000) {
            Serial.printf("[WARMUP] Progress: %.0f%% â†’ Level %d/%d (via AI_WARMUP)\n", 
                          progress * 100, currentWarmupLevel, levelBeforePause);
            lastWarmupDebug = millis();
          }
        }
      }
      else if (aiOverruleActive) {
        // NORMALE AI UPDATES
        extern AdvancedStressManager stressManager;
  
        BiometricData bio;
        bio.heartRate = sensorData.BPM;
        bio.temperature = sensorData.temperature;
        bio.gsrValue = sensorData.gsrSmooth;
        bio.timestamp = millis();
  
        stressManager.update(bio);
        
        // Haal AI beslissing op
        StressDecision decision = stressManager.getStressDecision();
        
        // Stuur AI override (elke seconde)
        static uint32_t lastAIUpdate = 0;
        if (millis() - lastAIUpdate > 1000) {
          float trustOverride = decision.recommendedSpeed / 7.0f;
          float sleeveOverride = trustOverride;
          
          sendESPNowMessage(
            trustOverride,
            sleeveOverride,
            true,
            "AI_OVERRIDE",
            decision.currentLevel,
            decision.vibeRecommended,
            decision.suctionRecommended
          );
          
          Serial.printf("[AI] Override sent: Speed=%d, Level=%d, Vibe=%d, Suction=%d\n",
                        decision.recommendedSpeed, decision.currentLevel,
                        decision.vibeRecommended, decision.suctionRecommended);
          
          lastAIUpdate = millis();
        }
      }

    } else {
      // Fallback: dummy data als ADS1115 niet beschikbaar
      float t = millis() / 1000.0f;
      body_gfx4_pushSample(G4_HART, 60 + 20 * sin(t * 2));
      body_gfx4_pushSample(G4_HUID, 50 + 10 * sin(t * 0.5));
      body_gfx4_pushSample(G4_TEMP, 36 + 1 * sin(t * 0.3));
      body_gfx4_pushSample(G4_ADEMHALING, 15 + 5 * sin(t));
    }
    
    // ESP-NOW data met animatie
    // HoofdESP: zeer agressieve sinus animatie die sneller beweegt bij hogere trust
    static float thrustPhase = 0;
    if (!pauseActive && trustSpeed > 0.05f) {  // Alleen animatie als NIET gepauzeerd EN trust > 0
      // Trust animatie (zie config.h om snelheid/hoogte aan te passen)
      float thrustFreq = trustSpeed * TRUST_ANIM_SNELHEID;
      thrustPhase += thrustFreq * 0.1f;  // Increment per 100ms
      float thrustAnim = 50 + TRUST_ANIM_HOOGTE * sin(thrustPhase);
      body_gfx4_pushSample(G4_HOOFDESP, thrustAnim);
    } else {
      thrustPhase = 0;  // Reset fase
      body_gfx4_pushSample(G4_HOOFDESP, 50);  // Vlakke lijn in midden bij pauze
    }
    
    body_gfx4_pushSample(G4_ZUIGEN, zuigActive ? 100 : 0);        // Zuigen: 0 of 100
    
    // Vibe: zaagrand patroon (zie config.h voor snelheid)
    static float vibePhase = 0;
    if (vibeOn) {
      vibePhase += VIBE_ANIM_SNELHEID;  // Zie config.h
      if (vibePhase > 1.0f) vibePhase = 0;
      body_gfx4_pushSample(G4_TRIL, vibePhase * 100);  // Lineair 0-100
    } else {
      vibePhase = 0;
      body_gfx4_pushSample(G4_TRIL, 50);  // Middenlijn bij uit
    }
    
    lastSensorPush = millis();
  }
  
  // ===== SENSOR + TOUCH DEBUG (elke 2 seconden) - UITGESCHAKELD =====
  // static uint32_t lastRead = 0;
  // if (millis() - lastRead > 2000) {
  //   Serial.println("\n=== I2C STATUS ===");
  //   
  //   // Touch status
  //   uint8_t touches = ts ? ts->touched() : 0;
  //   Serial.printf("[TOUCH Wire]   Touches: %d\n", touches);
  //   
  //   // ADS1115 sensor readout
  //   if (adsAvailable) {
  //     int16_t adc0 = ads.readADC_SingleEnded(0);
  //     int16_t adc1 = ads.readADC_SingleEnded(1);
  //     int16_t adc2 = ads.readADC_SingleEnded(2);
  //     int16_t adc3 = ads.readADC_SingleEnded(3);
  //     
  //     float v0 = ads.computeVolts(adc0);
  //     float v1 = ads.computeVolts(adc1);
  //     float v2 = ads.computeVolts(adc2);
  //     float v3 = ads.computeVolts(adc3);
  //     
  //     Serial.printf("[ADS1115] A0=%d (%.3fV) A1=%d (%.3fV)\n", adc0, v0, adc1, v1);
  //     Serial.printf("[ADS1115] A2=%d (%.3fV) A3=%d (%.3fV)\n", adc2, v2, adc3, v3);
  //     
  //     if (adc0 == 0 && adc1 == 0 && adc2 == 0 && adc3 == 0) {
  //       Serial.println("[WARNING] Alle ADC = 0 - I2C fout!");
  //     }
  //   } else {
  //     Serial.println("[ADS1115] NOT AVAILABLE");
  //   }
  //   
  //   // RTC readout
  //   if (rtcAvailable) {
  //     DateTime now = rtc.now();
  //     float temp = rtc.getTemperature();
  //     Serial.printf("[RTC] Time: %04d-%02d-%02d %02d:%02d:%02d\n",
  //                   now.year(), now.month(), now.day(),
  //                   now.hour(), now.minute(), now.second());
  //     Serial.printf("[RTC] Temp: %.2f C\n", temp);
  //   } else {
  //     Serial.println("[RTC] NOT AVAILABLE");
  //   }
  //   
  //   // EEPROM - skip (already tested in setup)
  //   if (eepromAvailable) {
  //     Serial.println("[EEPROM] OK (tested at startup)");
  //   } else {
  //     Serial.println("[EEPROM] NOT AVAILABLE");
  //   }
  //   
  //   Serial.println("==================\n");
  //   lastRead = millis();
  // }
  
  // ===== CSV RECORDING UPDATE =====
  updateCSVRecording();  // Update CSV bestand als recording actief is
  
  // ===== PLAYBACK UPDATE =====
  updatePlayback();  // Update playback als actief
  
  // ===== MULTIFUNPLAYER LOOP (als funscript enabled) =====
  static bool lastFunscriptState = false;
  if (funscriptEnabled != lastFunscriptState) {
    // Status veranderd
    if (funscriptEnabled) {
      Serial.println("[MFP] Funscript mode ENABLED - connecting to MultiFunPlayer...");
      mfpClient.enable(true);
      mfpClient.connect();
    } else {
      Serial.println("[MFP] Funscript mode DISABLED - disconnecting...");
      mfpClient.disconnect();
      mfpClient.enable(false);
    }
    lastFunscriptState = funscriptEnabled;
  }
  
  // MultiFunPlayer WebSocket loop (alleen als enabled)
  if (funscriptEnabled) {
    mfpClient.loop();
  }
  
  // ðŸ”¥ NIEUW: Process ESP-NOW retry queue
  processESPNowQueue();

  // ===== ESP-NOW HEARTBEAT (elke 5 seconden) =====
  static uint32_t lastHeartbeat = 0;
  if (espNowInitialized && (millis() - lastHeartbeat > 5000)) {
    sendESPNowMessage(1.0f, 1.0f, false, "HEARTBEAT", 0, false, false);
    lastHeartbeat = millis();
    
    // Toon laatste ontvangen data
    if (millis() - lastCommTime < 10000) {  // Als recent data ontvangen
      Serial.printf("[ESP-NOW] Last RX: T:%.1f S:%.1f Su:%.1f V:%d Z:%d Vac:%.1f P:%d Pos:%.0f%% Step:%d (%.1fs ago)\n",
                    trustSpeed, sleeveSpeed, suctionLevel, vibeOn, zuigActive, vacuumMbar,
                    pauseActive, sleevePercentage, hoofdESPSpeedStep,
                    (millis() - lastCommTime) / 1000.0f);
    } else {
      Serial.println("[ESP-NOW] No recent data from HoofdESP");
    }
    
    // Toon MultiFunPlayer status
    if (funscriptEnabled) {
Serial.printf("[MFP] Status: %s | Actions: %d | ML Overrides: %d (%.1f%%)\n",
                    mfpClient.isConnected() ? "Connected" : "Disconnected",
                    mfpClient.getTotalActions(),
                    mfpClient.getMLOverrides(),
                    mfpClient.getMLOverridePercentage());
    }
  }
  
  // ===== ENCODER INPUT (alleen in MENU mode) =====
  //if (currentMode == MODE_MENU) {
    handleEncoderInput();
  //}
  
  delay(10);  // Kleine delay voor stabiele polling
}
