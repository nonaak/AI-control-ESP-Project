/*  
  Body ESP SC01 Plus V3 – ADS1115 Sensor Migration
  - Vervangen: MAX30105 → Pulse sensor op ADS1115 A2
  - Vervangen: MCP9808 → NTC temperatuur op ADS1115 A3  
  - Vervangen: GPIO 34 GSR → GSR sensor op ADS1115 A0
  - NIEUW: Flex sensor (ademhaling) op ADS1115 A1
  - VERWIJDERD: RGB LED code (CYD specific)
  - I2C: Wire1 op GPIO 10 (SDA) + 11 (SCL) voor sensoren
*/

#include <Arduino.h>
#include <Wire.h>
#include <math.h>
#include <SPI.h>
#include <SD.h>
#include <Arduino_GFX_Library.h>
#include <esp_now.h>
#include <WiFi.h>

// ===== ADS1115 Sensor System (NIEUW!) =====
#include <Adafruit_ADS1X15.h>
Adafruit_ADS1115 ads;

#define SENSOR_SDA 10          // GPIO 10 = SDA voor sensoren
#define SENSOR_SCL 11          // GPIO 11 = SCL voor sensoren

// ADS1115 sensor calibratie
static int gsr_threshold = 0;
static float flex_baseline = 0.0f;
static int pulse_baseline = 0;

// NTC Temperature constanten (10kΩ @ 25°C, B=3950K)
#define R_TOP 33000.0          // 33kΩ serie weerstand
#define NTC_NOMINAL 10000.0
#define TEMP_NOMINAL 25.0
#define B_COEFFICIENT 3950.0

// Pulse sensor variabelen
static int pulse_max = 0;
static int pulse_min = 32767;
static bool beat_detected = false;
static unsigned long lastBeat = 0;

// ===== Screen dimensions voor SC01 Plus =====
const int SCR_W = 480;
const int SCR_H = 320;

// Math constanten
#ifndef PI
#define PI 3.14159265359
#endif
#ifndef TWO_PI
#define TWO_PI 6.28318530718
#endif

// >>> Rotatie van weergave (sync met input_touch.h)
#define DISPLAY_ROTATION 1
static uint8_t currentRotation = DISPLAY_ROTATION;

#include "body_config.h"
#include "body_display.h"
#include "input_touch.h"
#include "sensor_settings.h"
#include "menu_view.h"
#include "ai_overrule.h"
#include "system_settings_view.h"
#include "playlist_view.h"
#include "overrule_view.h"
#include "ai_analyze_view.h"
#include "ai_event_config_view.h"
#include "confirm_view.h"
#include "colors_view.h"
#include "ml_training_view.h"
#include "ai_training_view.h"
#include "ml_stress_analyzer.h"

// Display reference
extern Arduino_GFX *body_gfx;

// ===== SD Card =====
#define SD_CS_PIN 5
static bool sdCardAvailable = false;
static int nextFileNumber = 1;

// ===== Recording =====
static File recordingFile;
static uint32_t recordingStartTime = 0;
static uint32_t samplesRecorded = 0;

// ===== Event Logging =====
static File eventLogFile;
static bool eventLoggingActive = false;

// ===== Sensor waarden =====
static uint16_t BPM = 0;
static float tempValue = 0.0f;
static float gsrValue = 0.0f;
static float gsrSmooth = 0.0f;
static float ademhalingVal = 50.0f;  // Flex sensor waarde

// Filters voor pulse sensor
static float hp_y_prev = 0, x_prev = 0, bp_y_prev = 0;
static float envAbs = 1000, acDiv = 600.0f;

const float FS_HZ = 50.0f;
const float DT = 1.0f/FS_HZ;
const float HP_FC = 0.5f, HP_TAU = 1.0f/(2*PI*HP_FC), HP_A = HP_TAU/(HP_TAU+DT);
const float LP_FC = 5.0f, LP_TAU = 1.0f/(2*PI*LP_FC), LP_A = DT/(LP_TAU+DT);

// Dummy
static float dummyPhase = 0;

// UI states
bool isRecording=false;
static bool isPlaying=false, uiMenu=false;

// App modes
enum AppMode : uint8_t { MODE_MAIN=0, MODE_MENU, MODE_PLAYLIST, MODE_CONFIRM, MODE_SENSOR_SETTINGS, MODE_SYSTEM_SETTINGS, MODE_OVERRULE, MODE_AI_ANALYZE, MODE_AI_EVENT_CONFIG, MODE_COLORS, MODE_AI_TRAINING };
static AppMode mode = MODE_MAIN;

// Playback variabelen
static File playbackFile;
static bool isPlaybackActive = false;
static uint32_t playbackStartTime = 0;
static uint32_t nextSampleTime = 0;

// Confirmation dialog variabelen
enum ConfirmType { CONFIRM_DELETE_FILE, CONFIRM_FORMAT_SD };
static ConfirmType confirmType;
static String confirmData;

// ===== ESP-NOW Communicatie =====
static uint8_t hoofdESP_MAC[] = {0xE4, 0x65, 0xB8, 0x7A, 0x85, 0xE4};
static uint8_t bodyESP_MAC[] = {0x08, 0xD1, 0xF9, 0xDC, 0xC3, 0xA4};

static String commBuffer = "";
static uint32_t lastCommTime = 0;
static float trustSpeed = 0.0f, sleeveSpeed = 0.0f, suctionLevel = 0.0f, pauseTime = 0.0f;
static bool vibeOn = false;
static bool zuigActive = false;
static float vacuumMbar = 0.0f;
static bool pauseActive = false;
static bool lubeTrigger = false;
static float cyclusTijd = 10.0f;
static uint32_t lastLubeTriggerTime = 0;
static float sleevePercentage = 0.0f;
static bool espNowInitialized = false;

// ESP-NOW bericht structuren (ongewijzigd)
typedef struct __attribute__((packed)) {
  float trust;
  float sleeve;
  float suction;
  float pause;
  bool vibeOn;
  bool zuigActive;
  float vacuumMbar;
  bool pauseActive;
  bool lubeTrigger;
  float cyclusTijd;
  float sleevePercentage;
  uint8_t currentSpeedStep;
  char command[32];
} esp_now_receive_message_t;

typedef struct __attribute__((packed)) {
  float newTrust;
  float newSleeve;
  bool overruleActive;
  uint8_t stressLevel;
  bool vibeOn;
  bool zuigenOn;
  char command[32];
} esp_now_send_message_t;

// AI Overrule systeem variabelen
AIOverruleConfig aiConfig;
bool aiOverruleActive = false;
uint32_t lastAIUpdate = 0;
float currentTrustOverride = 1.0f;
float currentSleeveOverride = 1.0f;

// AI Test Control System
static bool redBackgroundActive = false;
static bool aiTestModeActive = false;
static bool aiControlActive = false;
static bool userPausedAI = false;
static float aiTargetTrust = 1.5f;
static bool aiTargetVibe = true;
static bool aiTargetZuig = false;
static uint32_t lastAITestUpdate = 0;

// AI Stress Management System
static bool aiStressModeActive = false;
static int currentStressLevel = 3;
static int aiStartSpeedStep = 3;
static int currentSpeedStep = 3;
static uint8_t hoofdESPSpeedStep = 3;
static uint32_t lastStressCheck = 0;
static uint32_t lastSpeedAdjust = 0;
static bool aiVacuumControl = true;
static bool aiVibeControl = false;
static uint32_t stressSimTimer = 0;

// ESP-NOW ontvangst callback
static void onESPNowReceive(const esp_now_recv_info *info, const uint8_t *incomingData, int len) {
  if (len != sizeof(esp_now_receive_message_t)) {
    Serial.printf("[ESP-NOW] SIZE MISMATCH! Got %d bytes, expected %d\n", len, sizeof(esp_now_receive_message_t));
    return;
  }
  
  esp_now_receive_message_t message;
  memcpy(&message, incomingData, sizeof(message));
  
  trustSpeed = message.trust;
  sleeveSpeed = message.sleeve;
  suctionLevel = message.suction;
  pauseTime = message.pause;
  vibeOn = message.vibeOn;
  zuigActive = message.zuigActive;
  vacuumMbar = message.vacuumMbar;
  pauseActive = message.pauseActive;
  
  if (message.lubeTrigger && !lubeTrigger) {
    lastLubeTriggerTime = millis();
    Serial.println("[LUBE SYNC] Nieuwe cyclus start gedetecteerd!");
  }
  lubeTrigger = message.lubeTrigger;
  cyclusTijd = message.cyclusTijd;
  sleevePercentage = message.sleevePercentage;
  hoofdESPSpeedStep = message.currentSpeedStep;
  
  lastCommTime = millis();
}

// ESP-NOW initialisatie
static bool initESPNow() {
  Serial.println("[ESP-NOW] Initializing...");
  
  WiFi.mode(WIFI_STA);
  WiFi.setChannel(4);
  
  if (esp_now_init() != ESP_OK) {
    Serial.println("[ESP-NOW] Init failed");
    return false;
  }
  
  esp_now_register_recv_cb(onESPNowReceive);
  
  esp_now_peer_info_t peerInfo;
  memset(&peerInfo, 0, sizeof(peerInfo));
  memcpy(peerInfo.peer_addr, hoofdESP_MAC, 6);
  peerInfo.channel = 4;
  peerInfo.encrypt = false;
  
  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
    Serial.println("[ESP-NOW] Failed to add peer");
    return false;
  }
  
  Serial.println("[ESP-NOW] Initialized successfully");
  return true;
}

// ESP-NOW verzend functie
static bool sendESPNowMessage(float newTrust, float newSleeve, bool overruleActive, const char* command, uint8_t stressLevel = 0, bool vibeOn = false, bool zuigenOn = false) {
  if (!espNowInitialized) return false;
  
  esp_now_send_message_t message;
  memset(&message, 0, sizeof(message));
  
  message.newTrust = newTrust;
  message.newSleeve = newSleeve;
  message.overruleActive = overruleActive;
  message.stressLevel = stressLevel;
  message.vibeOn = vibeOn;
  message.zuigenOn = zuigenOn;
  strncpy(message.command, command, sizeof(message.command) - 1);
  
  esp_err_t result = esp_now_send(hoofdESP_MAC, (uint8_t *)&message, sizeof(message));
  
  if (result == ESP_OK) {
    Serial.printf("[ESP-NOW] TX: T:%.1f S:%.1f Stress:%d Cmd:%s\n", 
                  newTrust, newSleeve, stressLevel, command);
    return true;
  }
  return false;
}

// AI functies (declaraties - implementatie blijft hetzelfde)
void startAITest();
void stopAITest();
void startAIStressManagement();
void stopAIStressManagement();
void handleAIStressManagement();
void handleSerialInput();
void handleAIPauseDetection();
void handleAITestControl();

// Scherm rotatie toggle
static void toggleScreenRotation() {
  bool wasRotated = (currentRotation != DISPLAY_ROTATION);
  
  if (currentRotation == DISPLAY_ROTATION) {
    currentRotation = (DISPLAY_ROTATION + 2) % 4;
  } else {
    currentRotation = DISPLAY_ROTATION;
  }
  
  body_gfx->setRotation(currentRotation);
  body_gfx->fillScreen(BODY_CFG.COL_BG);
  
  inputTouchBegin(body_gfx);
  bool isNowRotated = (currentRotation != DISPLAY_ROTATION);
  inputTouchSetRotated(isNowRotated);
}

// SD card functies
static void initSDCard() {
  if (SD.begin(SD_CS_PIN)) {
    sdCardAvailable = true;
    while (SD.exists("/data" + String(nextFileNumber) + ".csv")) {
      nextFileNumber++;
    }
    Serial.println("[BODY] SD card gereed");
  } else {
    sdCardAvailable = false;
    Serial.println("[BODY] SD card fout!");
  }
}

void startRecording() {
  if (!sdCardAvailable) {
    Serial.println("[BODY] Geen SD card!");
    return;
  }
  
  String filename = "/data" + String(nextFileNumber) + ".csv";
  recordingFile = SD.open(filename, FILE_WRITE);
  
  if (recordingFile) {
    recordingFile.println("Time,Heart,Temp,Skin,Oxygen,Beat,Trust,Sleeve,Suction,Pause,Adem,Tril,ZuigActive,VacuumMbar");
    recordingStartTime = millis();
    samplesRecorded = 0;
    Serial.printf("[BODY] Opname gestart: %d\n", nextFileNumber);
  } else {
    isRecording = false;
    Serial.println("[BODY] Kan niet opnemen!");
  }
}

void stopRecording() {
  if (recordingFile) {
    recordingFile.close();
    Serial.printf("[BODY] Opname gestopt. Samples: %u\n", samplesRecorded);
    nextFileNumber++;
  }
}

static void recordSampleExtended(float heartVal, float tempVal, float huidVal, float oxyVal, bool beat,
                                float trust, float sleeve, float suction, float pause, float adem, float tril) {
  if (!isRecording || !recordingFile) return;
  
  uint32_t timeMs = millis() - recordingStartTime;
  
  recordingFile.print(timeMs);
  recordingFile.print(",");
  recordingFile.print(heartVal, 2);
  recordingFile.print(",");
  recordingFile.print(tempVal, 2);
  recordingFile.print(",");
  recordingFile.print(huidVal, 2);
  recordingFile.print(",");
  recordingFile.print(oxyVal, 2);
  recordingFile.print(",");
  recordingFile.print(beat ? 1 : 0);
  recordingFile.print(",");
  recordingFile.print(trust, 2);
  recordingFile.print(",");
  recordingFile.print(sleeve, 2);
  recordingFile.print(",");
  recordingFile.print(suction, 2);
  recordingFile.print(",");
  recordingFile.print(pause, 2);
  recordingFile.print(",");
  recordingFile.print(adem, 2);
  recordingFile.print(",");
  recordingFile.print(tril, 2);
  recordingFile.print(",");
  recordingFile.print(zuigActive ? 1 : 0);
  recordingFile.print(",");
  recordingFile.println(vacuumMbar, 2);
  
  samplesRecorded++;
  
  if (samplesRecorded % 100 == 0) {
    recordingFile.flush();
  }
}

// ===== ADS1115 SENSOR FUNCTIES (NIEUW!) =====

static void calibrateADS1115Sensors() {
  Serial.println("\n[CALIBRATIE] Start sensor calibratie...");
  Serial.println("[CALIBRATIE] Raak sensoren NIET aan...");
  delay(2000);
  
  // GSR calibratie (A0)
  long gsr_sum = 0;
  for(int i = 0; i < 500; i++) {
    gsr_sum += ads.readADC_SingleEnded(0);
    delay(5);
  }
  gsr_threshold = gsr_sum / 500;
  Serial.printf("[CALIBRATIE] GSR threshold = %d\n", gsr_threshold);
  
  // Flex baseline (A1)
  long flex_sum = 0;
  for(int i = 0; i < 100; i++) {
    flex_sum += ads.readADC_SingleEnded(1);
    delay(10);
  }
  flex_baseline = ads.computeVolts(flex_sum / 100);
  Serial.printf("[CALIBRATIE] Flex baseline = %.3fV\n", flex_baseline);
  
  // Pulse baseline (A2)
  long pulse_sum = 0;
  for(int i = 0; i < 100; i++) {
    pulse_sum += ads.readADC_SingleEnded(2);
    delay(10);
  }
  pulse_baseline = pulse_sum / 100;
  Serial.printf("[CALIBRATIE] Pulse baseline = %d\n", pulse_baseline);
  
  Serial.println("[CALIBRATIE] Klaar!\n");
}

static void readADS1115Sensors() {
  // ===== A0: GSR Sensor =====
  int gsr_raw = ads.readADC_SingleEnded(0);
  gsrValue = (float)gsr_raw;
  
  // Smoothing
  float smoothFactor = sensorConfig.gsrSmoothing;
  gsrSmooth = gsrSmooth * (1.0f - smoothFactor) + gsrValue * smoothFactor;
  
  // ===== A1: Flex Sensor (Ademhaling) =====
  int flex_raw = ads.readADC_SingleEnded(1);
  float flex_voltage = ads.computeVolts(flex_raw);
  ademhalingVal = 100 - ((flex_voltage - 0.5) / 2.0 * 100);
  ademhalingVal = constrain(ademhalingVal, 0, 100);
  
  // ===== A2: Pulse Sensor =====
  int pulse_raw = ads.readADC_SingleEnded(2);
  
  // Update min/max voor threshold
  if(pulse_raw > pulse_max) pulse_max = pulse_raw;
  if(pulse_raw < pulse_min) pulse_min = pulse_raw;
  
  int pulse_threshold_val = pulse_min + ((pulse_max - pulse_min) / 2);
  
  // Beat detection
  if(pulse_raw > pulse_threshold_val && !beat_detected) {
    unsigned long now = millis();
    if(lastBeat > 0) {
      unsigned long ibi = now - lastBeat;
      if(ibi > 300 && ibi < 2000) {
        BPM = 60000 / ibi;
      }
    }
    lastBeat = now;
    beat_detected = true;
  }
  if(pulse_raw < pulse_threshold_val) {
    beat_detected = false;
  }
  
  // Reset min/max elke 2 seconden
  static unsigned long lastReset = 0;
  if(millis() - lastReset > 2000) {
    pulse_max = pulse_baseline;
    pulse_min = pulse_baseline;
    lastReset = millis();
  }
  
  // ===== A3: NTC Temperatuur =====
  int ntc_raw = ads.readADC_SingleEnded(3);
  float ntc_voltage = ads.computeVolts(ntc_raw);
  
  if(ntc_voltage < 0.1) {
    tempValue = 0.0f;  // Sensor open
  } else if(ntc_voltage > 3.2) {
    tempValue = 0.0f;  // Sensor short
  } else {
    float ntc_resistance = R_TOP * ntc_voltage / (3.3 - ntc_voltage);
    float steinhart = ntc_resistance / NTC_NOMINAL;
    steinhart = log(steinhart);
    steinhart /= B_COEFFICIENT;
    steinhart += 1.0 / (TEMP_NOMINAL + 273.15);
    steinhart = 1.0 / steinhart;
    tempValue = steinhart - 273.15 + sensorConfig.tempOffset;
  }
}

// ===== SENSOR INITIALISATIE =====
static void initSensors() {
  Serial.println("[BODY] Initializing sensors...");
  
  // Start sensor I2C bus (Wire1 op pins 10/11)
  Wire1.begin(SENSOR_SDA, SENSOR_SCL);
  Wire1.setClock(400000);
  
  // Initialize ADS1115
  if (!ads.begin(0x48, &Wire1)) {
    Serial.println("[BODY] ADS1115 niet gevonden!");
    Serial.println("[BODY] Check I2C bedrading op GPIO 10/11");
  } else {
    Serial.println("[BODY] ADS1115 OK!");
    ads.setGain(GAIN_ONE);              // ±4.096V
    ads.setDataRate(RATE_ADS1115_128SPS); // 128 samples/sec
    
    // Calibreer sensors
    calibrateADS1115Sensors();
  }
  
  // ESP-NOW communicatie initialiseren
  espNowInitialized = initESPNow();
  if (espNowInitialized) {
    Serial.println("[BODY] ESP-NOW gereed!");
  } else {
    Serial.println("[BODY] ESP-NOW fout!");
  }
}

static void readESP32Comm() {
  // ESP-NOW berichten worden automatisch verwerkt via callback
  // Timeout check
  if (millis() - lastCommTime > sensorConfig.commTimeout * 1000) {
    trustSpeed = sleeveSpeed = suctionLevel = pauseTime = 0.0f;
    zuigActive = false;
    vacuumMbar = 0.0f;
    pauseActive = false;
    lubeTrigger = false;
    cyclusTijd = 10.0f;
  }
}

// AI Overrule logica (ongewijzigd, maar gebruikt nieuwe sensor waarden)
static void updateAIOverrule(float heartRate, float temperature, float gsrLevel) {
  if (!aiConfig.enabled) {
    currentTrustOverride = 1.0f;
    currentSleeveOverride = 1.0f;
    aiOverruleActive = false;
    return;
  }
  
  uint32_t now = millis();
  if (now - lastAIUpdate < 1000) return;
  lastAIUpdate = now;
  
  bool riskDetected = false;
  float riskLevel = 0.0f;
  
  if (heartRate < aiConfig.hrLowThreshold || heartRate > aiConfig.hrHighThreshold) {
    riskLevel += 0.4f;
    riskDetected = true;
  }
  
  if (temperature > aiConfig.tempHighThreshold) {
    riskLevel += 0.3f;
    riskDetected = true;
  }
  
  if (gsrLevel > aiConfig.gsrHighThreshold) {
    riskLevel += 0.3f;
    riskDetected = true;
  }
  
  if (riskDetected && riskLevel > 0.2f) {
    float targetTrust = 1.0f - (riskLevel * (1.0f - aiConfig.trustReduction));
    currentTrustOverride = min(currentTrustOverride, targetTrust);
    currentSleeveOverride = 1.0f;
    aiOverruleActive = true;
  } else {
    currentTrustOverride = min(1.0f, currentTrustOverride + aiConfig.recoveryRate);
    currentSleeveOverride = 1.0f;
    
    if (currentTrustOverride >= 0.99f) {
      aiOverruleActive = false;
    }
  }
  
  static float lastSentTrust = 1.0f, lastSentSleeve = 1.0f;
  if (abs(currentTrustOverride - lastSentTrust) > 0.05f || 
      abs(currentSleeveOverride - lastSentSleeve) > 0.05f) {
    sendESPNowMessage(currentTrustOverride, currentSleeveOverride, aiOverruleActive, "AI_OVERRIDE");
    lastSentTrust = currentTrustOverride;
    lastSentSleeve = currentSleeveOverride;
  }
}

// Mode switching functies (verkort - implementatie blijft grotendeels hetzelfde)
static void enterMain() {
  mode = MODE_MAIN;
  uiMenu = false;
  // ... rest van implementatie
  Serial.println("[BODY] Main screen");
}

static void enterMenu() {
  mode = MODE_MENU;
  uiMenu = true;
  Serial.println("[BODY] Menu mode");
}

// ... (andere enter functies blijven hetzelfde)

void setup() {
  Serial.begin(115200);
  Serial.println("[BODY] Starting Body ESP SC01 Plus...");
  Serial.println("[BODY] ADS1115 Sensor System Active");
  
  // Initialize display system
  body_gfx->begin();
  body_gfx->setRotation(DISPLAY_ROTATION);
  body_gfx->fillScreen(BODY_CFG.COL_BG);
  
  // Initialize touch I2C (intern op pins 6/5 via body_display)
  // Wire.begin(6, 5) wordt automatisch gedaan door body_display
  
  // Initialize touch system
  inputTouchBegin(body_gfx);
  
  // Load sensor settings
  loadSensorConfig();
  Serial.println("[BODY] Sensor configuratie geladen");
  
  // Initialize sensors (ADS1115 op Wire1, pins 10/11)
  initSensors();
  
  // Initialize SD card
  initSDCard();
  
  // Initialize ML Stress Analyzer
  Serial.println("[BODY] Initializing ML Stress Analyzer...");
  if (ml_begin()) {
    Serial.println("[BODY] ML Stress Analyzer OK");
  } else {
    Serial.println("[BODY] ML init failed, continuing without ML");
  }
  
  // Reset AI status
  aiTestModeActive = false;
  aiStressModeActive = false;
  aiControlActive = false;
  userPausedAI = false;
  redBackgroundActive = false;
  
  // Enter main mode
  enterMain();
  
  Serial.println("[BODY] Initialization complete");
  Serial.println("[BODY] Sensors: GSR(A0), Flex(A1), Pulse(A2), NTC(A3)");
}

void loop() {
  if (mode == MODE_MAIN) {
    // Check voor rode achtergrond (AI gepauzeerd)
    if (redBackgroundActive) {
      body_gfx->fillScreen(0xF800);
      body_gfx->setTextColor(0xFFFF, 0xF800);
      body_gfx->setTextSize(2);
      
      String pauseMsg = "AI GEPAUZEERD";
      int16_t x, y; uint16_t w, h;
      body_gfx->getTextBounds(pauseMsg, 0, 0, &x, &y, &w, &h);
      body_gfx->setCursor((SCR_W - w) / 2, SCR_H / 2 - 40);
      body_gfx->print(pauseMsg);
      
      body_gfx->setTextSize(1);
      String touchMsg = "Raak scherm aan om door te gaan";
      body_gfx->getTextBounds(touchMsg, 0, 0, &x, &y, &w, &h);
      body_gfx->setCursor((SCR_W - w) / 2, SCR_H / 2);
      body_gfx->print(touchMsg);
      
      int16_t tx, ty;
      if (inputTouchRead(tx, ty)) {
        redBackgroundActive = false;
        
        if (userPausedAI) {
          userPausedAI = false;
          aiControlActive = true;
          
          if (aiStressModeActive) {
            float resumeTrust = 0.1f;
            sendESPNowMessage(resumeTrust, 1.0f, true, "AI_STRESS_RESUME");
            Serial.printf("[AI STRESS] Resume bij stress level %d\n", currentStressLevel);
          } else if (aiTestModeActive) {
            aiTargetTrust = 0.1f;
            sendESPNowMessage(aiTargetTrust, 1.0f, true, "AI_RESUME_SLOW");
            Serial.println("[AI TEST] Resume slow");
          }
        }
        
        enterMain();
      }
      
      delay(50);
      return;
    }
    
    // Lees alle sensoren via ADS1115
    readADS1115Sensors();
    readESP32Comm();
    
    // Gebruik echte sensor data
    float heartVal = (float)BPM;
    float tempVal = tempValue;
    float huidVal = gsrSmooth;
    
    // Feed sensor data to ML analyzer (elke 100ms)
    static uint32_t lastMLUpdate = 0;
    if (millis() - lastMLUpdate >= 100) {
      mlAnalyzer.addSensorSample(heartVal, tempVal, huidVal);
      lastMLUpdate = millis();
    }
    
    // Dummy oxygen (nog geen echte sensor)
    dummyPhase += 0.1f;
    if (dummyPhase > TWO_PI) dummyPhase -= TWO_PI;
    float oxyVal = 95 + 2 * sin(dummyPhase/7);
    
    // Beat detection voor display
    bool beat = (BPM > 40 && BPM < 200);  // Simpele beat indicator
    
    // Process AI systems
    updateAIOverrule(heartVal, tempVal, huidVal);
    handleAIPauseDetection();
    handleAITestControl();
    handleAIStressManagement();
    handleSerialInput();
    
    // Send heartbeat
    static uint32_t lastHeartbeat = 0;
    if (millis() - lastHeartbeat >= 2000) {
      bool effectiveAI = aiOverruleActive || aiStressModeActive || aiTestModeActive;
      sendESPNowMessage(currentTrustOverride, currentSleeveOverride, effectiveAI, "HEARTBEAT");
      lastHeartbeat = millis();
    }
    
    // Record data if recording
    if (isRecording) {
      float trilVal = vibeOn ? 100.0f : 0.0f;
      recordSampleExtended(heartVal, tempVal, huidVal, oxyVal, beat, 
                          trustSpeed, sleeveSpeed, suctionLevel, pauseTime, 
                          ademhalingVal, trilVal);
    }
    
    // Debug output (elke 2 seconden)
    static uint32_t lastDebugTime = 0;
    if (millis() - lastDebugTime >= 2000) {
      Serial.printf("[SENSORS] HR:%d Temp:%.1f GSR:%.0f Flex:%.0f%%\n", 
                    BPM, tempVal, huidVal, ademhalingVal);
      Serial.printf("[HOOFD] Trust:%.1f Sleeve:%.1f Suction:%.1f\n",
                    trustSpeed, sleeveSpeed, suctionLevel);
      lastDebugTime = millis();
    }
    
    // Touch input handling (verkort - zie origineel voor volledig)
    // ... touch events ...
    
    delay(20);
    return;
  }
  
  // Menu modes (verkort - implementatie blijft hetzelfde als origineel)
  if (mode == MODE_MENU) {
    // Menu polling...
    delay(10);
    return;
  }
  
  // ... andere modes ...
  
  delay(10);
}

// AI functie implementaties (verkort - zie origineel voor volledig)
void startAITest() {
  aiTestModeActive = true;
  aiControlActive = false;
  if (BODY_CFG.autoRecordSessions && !isRecording) {
    startRecording();
  }
  Serial.println("[AI TEST] Started");
}

void stopAITest() {
  aiTestModeActive = false;
  if (BODY_CFG.autoRecordSessions && isRecording) {
    stopRecording();
  }
  sendESPNowMessage(1.0f, 1.0f, false, "MANUAL_CONTROL");
}

void startAIStressManagement() {
  aiStressModeActive = true;
  if (BODY_CFG.autoRecordSessions && !isRecording) {
    startRecording();
  }
  Serial.println("[AI STRESS] Started");
}

void stopAIStressManagement() {
  aiStressModeActive = false;
  if (BODY_CFG.autoRecordSessions && isRecording) {
    stopRecording();
  }
  sendESPNowMessage(1.0f, 1.0f, false, "MANUAL_CONTROL");
}

void handleAIStressManagement() {
  // Implementatie blijft hetzelfde als origineel
}

void handleSerialInput() {
  // Implementatie blijft hetzelfde als origineel
}

void handleAIPauseDetection() {
  // Implementatie blijft hetzelfde als origineel
}

void handleAITestControl() {
  // Implementatie blijft hetzelfde als origineel
}
